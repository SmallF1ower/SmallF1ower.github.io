<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> EZ2write_shellcode_with_ASM · f1ower's Blog</title><meta name="description" content="EZ2write_shellcode_with_ASM - f1ower"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="f1ower's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/SmallF1ower" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">EZ2write_shellcode_with_ASM</h1><div class="post-info">Nov 19, 2019</div><div class="post-content"><p>最近还是在看路由器这本书，里面有讲有关mips32下的Shellcode编写<br>我感觉这个编写思路适合几乎所有的Linux操作系统下的编写，所以也认真的分析和写，故此记录  </p>
<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>我对于shellcode的理解是一段硬编码<br>在以前接触Windows的时候我在Visual Studio中编译好了简单的C程序之后会使用调试功能看汇编并提取其中的部分，然后新建一个测试程序并用指针指向该部分的硬编码去执行，我认为这很有趣<br>Linux也是如此，但是Linux的机制更加简单，方便直接进行系统调用  </p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>在x86架构下的Linux中，几乎所有的syscall都是采用int 0x80这样的软中断来进行<br>然并卵，在mips架构下的Linux中又没有这样的软中断<br>但是mips架构下有syscall指令可以进行syscall，但是和x86下有一些区别在于不同的调用传参方式，不同的系统调用号等等…  </p>
<h3 id="how-2-syscall"><a href="#how-2-syscall" class="headerlink" title="how 2 syscall?"></a>how 2 syscall?</h3><p>我不太喜欢书中那种直接给结论的方式，所以我自己写一个来简单分析：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        execve(<span class="string">"/bin/sh"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-gcc -static execve.c -o execve      </span><br><span class="line">execve.c: In function ‘main’:</span><br><span class="line">execve.c:5:2: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]</span><br><span class="line">  execve("/bin/sh", 0, 0);</span><br><span class="line">  ^~~~~~</span><br><span class="line"><span class="meta">$</span> qemu-mips execve   </span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>IDA看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00400370 .globl main</span><br><span class="line">.text:00400370 main:</span><br><span class="line">.text:00400370</span><br><span class="line">.text:00400370 var_10= -0x10</span><br><span class="line">.text:00400370 var_8= -8</span><br><span class="line">.text:00400370 var_4= -4</span><br><span class="line">.text:00400370</span><br><span class="line">.text:00400370 addiu   $sp, -0x20</span><br><span class="line">.text:00400374 sw      $ra, 0x20+var_4($sp)</span><br><span class="line">.text:00400378 sw      $fp, 0x20+var_8($sp)</span><br><span class="line">.text:0040037C move    $fp, $sp</span><br><span class="line">.text:00400380 li      $gp, 0x4271E0</span><br><span class="line">.text:00400388 sw      $gp, 0x20+var_10($sp)</span><br><span class="line">.text:0040038C move    $a2, $zero</span><br><span class="line">.text:00400390 move    $a1, $zero</span><br><span class="line">.text:00400394 lui     $v0, 0x41</span><br><span class="line">.text:00400398 addiu   $a0, $v0, (aBinSh - 0x410000)  # &quot;/bin/sh&quot;</span><br><span class="line">.text:0040039C la      $v0, execve</span><br><span class="line">.text:004003A0 move    $t9, $v0</span><br><span class="line">.text:004003A4 bal     execve</span><br><span class="line">.text:004003A8 nop</span><br></pre></td></tr></table></figure>

<p>$a0==指向”/bin/sh”的指针<br>$a1==0<br>$a2==0<br>跟进execve(“/bin/sh”,0,0);  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:004003D0                 .globl execve</span><br><span class="line">.text:004003D0 execve:                                  # CODE XREF: main+34↑p</span><br><span class="line">.text:004003D0                                          # DATA XREF: main+2C↑o ...</span><br><span class="line">.text:004003D0                 li      $gp, 0x26E10</span><br><span class="line">.text:004003D8                 addu    $gp, $t9</span><br><span class="line">.text:004003DC                 li      $v0, 0xFAB</span><br><span class="line">.text:004003E0                 syscall 0</span><br><span class="line">.text:004003E4                 beqz    $a3, locret_400404</span><br><span class="line">.text:004003E8                 nop</span><br><span class="line">.text:004003EC                 rdhwr   $v1, $29</span><br><span class="line">.text:004003F0                 move    $a0, $v1</span><br><span class="line">.text:004003F4                 la      $v1, 0xFFFF9000</span><br><span class="line">.text:004003F8                 addu    $v1, $a0</span><br><span class="line">.text:004003FC                 sw      $v0, 0($v1)</span><br><span class="line">.text:00400400                 li      $v0, 0xFFFFFFFF</span><br><span class="line">.text:00400404</span><br><span class="line">.text:00400404 locret_400404:                           # CODE XREF: execve+14↑j</span><br><span class="line">.text:00400404                 jr      $ra</span><br><span class="line">.text:00400408                 nop</span><br></pre></td></tr></table></figure>

<p>忽略对$gp全局指针的赋值，可以看到并没有修改$0-$2这三个参数，直接使用这三个参数<br>这个有个细节，在x86中的syscall是需要传递一个系统调用号的，这里也是一样  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li      $v0, 0xFAB</span><br></pre></td></tr></table></figure>

<p>这条指令将一个莫名奇妙的数字赋值给了$v0，而$v0一般是用于储存返回值的，用在这里挺奇怪的，其实这就调用的约定了<br>syscall指令之前，将系统调用号放到$v0中，系统调用的参数正常存放在$a0-$a3中…<br>伪c代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall($v0=syscall_number, $a0=args1, $a1=args2, ...);</span><br></pre></td></tr></table></figure>

<h3 id="syscall-number"><a href="#syscall-number" class="headerlink" title="syscall number"></a>syscall number</h3><p>和x86架构下不一样，mips构架也有自己的系统调用号<br>/include/asm/unistd.c  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_Linux      4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_o32.h&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>/include/asm/unistd_o32.h  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_MIPS_UNISTD_O32_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_MIPS_UNISTD_O32_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syscall    (__NR_Linux + 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit       (__NR_Linux + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork       (__NR_Linux + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read       (__NR_Linux + 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write      (__NR_Linux + 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open       (__NR_Linux + 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close      (__NR_Linux + 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid    (__NR_Linux + 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat      (__NR_Linux + 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link       (__NR_Linux + 9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink     (__NR_Linux + 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve     (__NR_Linux + 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir      (__NR_Linux + 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time       (__NR_Linux + 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod      (__NR_Linux + 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod      (__NR_Linux + 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown     (__NR_Linux + 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_break      (__NR_Linux + 17)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unused18   (__NR_Linux + 18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek      (__NR_Linux + 19)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid     (__NR_Linux + 20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount      (__NR_Linux + 21)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount     (__NR_Linux + 22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid     (__NR_Linux + 23)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid     (__NR_Linux + 24)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stime      (__NR_Linux + 25)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace     (__NR_Linux + 26)</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>书中的例子为：<br>execve.S  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">        li      $a2,0x111	;保证$a2&gt;0</span><br><span class="line">p:      bltzal  $a2,p	;不会跳转，但是由于cpu流水线，会把addiu $sp,$sp,-32这条指令的地址放到$ra中</span><br><span class="line">        li      $a2,0	;$a2==0</span><br><span class="line">        addiu   $sp,$sp,-32</span><br><span class="line">        addiu   $a0,$ra,28	;$a0==sc的地址(依靠固定偏移算的)</span><br><span class="line">        sw      $a0,-24($sp)</span><br><span class="line">        sw      $zero,-20($sp)</span><br><span class="line">        addiu   $a1,$sp,-24	;$a1=&#123;$a0的地址, 0&#125;</span><br><span class="line">        li      $v0,4011	;系统调用号，execve为10进制的4011</span><br><span class="line">        syscall</span><br><span class="line">sc:</span><br><span class="line">        .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure>

<p>因为很久没有看汇编了，所以比较生疏，mips的汇编也是非常有趣的，注释在代码中<br>这里分析之后推测C代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span>; = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    args[<span class="number">0</span>] = <span class="built_in">string</span>;</span><br><span class="line">    args[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    execve(<span class="built_in">string</span>, args, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-as execve.S -o s.o            </span><br><span class="line"><span class="meta">$</span> mips-linux-ld s.o -o execve</span><br><span class="line"><span class="meta">$</span> qemu-mips execve</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>没有什么问题</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我觉得书中的例子是execve(“/bin/sh”, {“/bin/sh”, 0}, 0);有点长<br>我整一个更短的来练手一下吧：<br>exe.S  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">        li      $a2,0x111</span><br><span class="line">p:      bltzal  $a2,p</span><br><span class="line">        li      $a2,0</span><br><span class="line">        addiu   $a0,$ra,0x10</span><br><span class="line">        li      $a1,0</span><br><span class="line">        li      $v0,4011</span><br><span class="line">        syscall</span><br><span class="line">sc:</span><br><span class="line">        .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mips-linux-as exe.S -o exe.o </span><br><span class="line"><span class="meta">$</span> mips-linux-ld exe.o -o exe </span><br><span class="line"><span class="meta">$</span> qemu-mips exe   </span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>去掉了对于$a1的赋值，事实证明还是可以直接执行   </p>
<h3 id="提取shellcode"><a href="#提取shellcode" class="headerlink" title="提取shellcode"></a>提取shellcode</h3><p>看一下代码段有多大：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> readelf -S exe</span><br><span class="line">There are 8 section headers, starting at offset 0x2ac:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .MIPS.abiflags    MIPS_ABIFLAGS   00400098 000098 000018 18   A  0   0  8</span><br><span class="line">  [ 2] .reginfo          MIPS_REGINFO    004000b0 0000b0 000018 18   A  0   0  4</span><br><span class="line">  [ 3] .text             PROGBITS        004000d0 0000d0 000030 00  AX  0   0 16</span><br><span class="line">  [ 4] .gnu.attributes   GNU_ATTRIBUTES  00000000 000100 000010 00      0   0  1</span><br><span class="line">  [ 5] .symtab           SYMTAB          00000000 000110 000110 10      6  10  4</span><br><span class="line">  [ 6] .strtab           STRTAB          00000000 000220 000042 00      0   0  1</span><br><span class="line">  [ 7] .shstrtab         STRTAB          00000000 000262 000049 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>

<p>两个Shell，一个Shell用qemu起一个gdb调试进程，另一边用gdb target remote远程调试  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disassemble /r</span><br><span class="line">Dump of assembler code for function _ftext:</span><br><span class="line">=&gt; 0x004000d0 &lt;+0&gt;:	24 06 01 11	li	a2,273</span><br></pre></td></tr></table></figure>

<p>由于符号的原因，gdb在disass的时候有点小问题  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disassemble /r</span><br><span class="line">Dump of assembler code for function p:</span><br><span class="line">=&gt; 0x004000d4 &lt;+0&gt;:	04 d0 ff ff	bltzal	a2,0x4000d4 &lt;p&gt;</span><br><span class="line">   0x004000d8 &lt;+4&gt;:	24 06 00 00	li	a2,0</span><br><span class="line">   0x004000dc &lt;+8&gt;:	27 e4 00 10	addiu	a0,ra,16</span><br><span class="line">   0x004000e0 &lt;+12&gt;:	24 05 00 00	li	a1,0</span><br><span class="line">   0x004000e4 &lt;+16&gt;:	24 02 0f ab	li	v0,4011</span><br><span class="line">   0x004000e8 &lt;+20&gt;:	00 00 00 0c	syscall</span><br></pre></td></tr></table></figure>

<p>还有sc标号之后的数据：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x /16xb sc</span><br><span class="line">0x4000ec &lt;sc&gt;:	0x2f	0x62	0x69	0x6e	0x2f	0x73	0x68	0x00</span><br><span class="line">0x4000f4 &lt;sc+8&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br></pre></td></tr></table></figure>

<p>整理的时候注意对其即可  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">"\x24\x06\x01\x11"</span>    <span class="comment">//li	a2,273</span></span><br><span class="line"><span class="string">"\x04\xd0\xff\xff"</span>    <span class="comment">//bltzal	a2,0x4000d4 &lt;p&gt;</span></span><br><span class="line"><span class="string">"\x24\x06\x00\x00"</span>    <span class="comment">//li	a2,0</span></span><br><span class="line"><span class="string">"\x27\xe4\x00\x10"</span>    <span class="comment">//addiu	a0,ra,16</span></span><br><span class="line"><span class="string">"\x24\x05\x00\x00"</span>    <span class="comment">//li	a1,0</span></span><br><span class="line"><span class="string">"\x24\x02\x0f\xab"</span>    <span class="comment">//li	v0,4011</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x0c"</span>    <span class="comment">//syscall</span></span><br><span class="line"><span class="string">"\x2f\x62\x69\x6e"</span>    <span class="comment">// "/bin/sh"</span></span><br><span class="line"><span class="string">"\x2f\x73\x68\x00"</span>    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法有个好处，$a0为execve()的第一个参数，随时都可以替换，比较灵活  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用汇编写点简单的即可掌握，不拘泥的大胆写就好了，有问题就上gdb调  </p>
<h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h3><p>shellcode.c  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">"\x24\x06\x01\x11"</span>      <span class="comment">//li    a2,273</span></span><br><span class="line"><span class="string">"\x04\xd0\xff\xff"</span>      <span class="comment">//bltzal        a2,0x4000d4 &lt;p&gt;</span></span><br><span class="line"><span class="string">"\x24\x06\x00\x00"</span>      <span class="comment">//li    a2,0</span></span><br><span class="line"><span class="string">"\x27\xe4\x00\x10"</span>      <span class="comment">//addiu a0,ra,16</span></span><br><span class="line"><span class="string">"\x24\x05\x00\x00"</span>      <span class="comment">//li    a1,0</span></span><br><span class="line"><span class="string">"\x24\x02\x0f\xab"</span>      <span class="comment">//li    v0,4011</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x0c"</span>      <span class="comment">//syscall</span></span><br><span class="line"><span class="string">"\x2f\x62\x69\x6e"</span>      <span class="comment">// /bin/sh</span></span><br><span class="line"><span class="string">"\x2f\x73\x68\x00"</span>      <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">void</span> (*s)(<span class="keyword">void</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shellcode size is: %d\n"</span>, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">        s = shellcode;</span><br><span class="line">        s();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*] work done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2019/12/22/Thinking-and-communication-about-how-I-go-to-study/" class="prev">PREV</a><a href="/2019/11/14/Simple-mips-stackoverflow/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">f1ower</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>